// protocol Lessonfor running pcr for one sample using a mastermix
protocol Lesson0_PCR_MMX

import (
	"fmt"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/enzymes"
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"strings"
)

// Input parameters for this protocol Lesson(data)
Parameters (
	// PCRprep parameters:

	// Total volume for a single reaction; the reaction will be topped up with ReactionBuffer (usually water) to reach this volume
	TotalReactionVolume Volume
	MasterMixVolume Volume
	PrimersalreadyAddedtoMasterMix bool
	PolymeraseAlreadyaddedtoMastermix bool
	FwdPrimerVol Volume
	RevPrimerVol Volume
	Templatevolume Volume
	PolymeraseVolume Volume
	ReactionName string
	TemplateName string
	FwdPrimerName string
	RevPrimerName string
	WellPosition string
	Targetsequence DNASequence
	FwdPrimerSeq DNASequence
	RevPrimerSeq DNASequence
	/*
		// let's be ambitious and try this as part of type polymerase Polymeraseconc Volume

		//Templatetype string  // e.g. colony, genomic, pure plasmid... will effect efficiency. We could get more sophisticated here later on...
		//FullTemplatesequence string // better to use Sid's type system here after proof of concept
		//FullTemplatelength int	// clearly could be calculated from the sequence... Sid will have a method to do this already so check!
		//TargetTemplatesequence string // better to use Sid's type system here after proof of concept
		//TargetTemplatelengthinBP int
	*/
	// Reaction parameters: (could be a entered as thermocycle parameters type possibly?)
	Numberofcycles int
	InitDenaturationtime Time
	Denaturationtime Time
	//Denaturationtemp Temperature
	Annealingtime Time
	AnnealingTemp Temperature // Should be calculated from primer and template binding
	Extensiontime Time        // should be calculated from template length and polymerase rate
	Finalextensiontime Time
)

// Data which is returned from this protocol, and data types
Data (
	FWDPrimerBindingSiteinTemplate int
	RevPrimerBindingSiteinTemplate int
)

// Physical Inputs to this protocol Lessonwith types
Inputs (
	// Buffer to use to top up the reaction to TotalReactionVolume. Typical buffer for this would be water.
	ReactionBuffer *LHComponent
	FwdPrimer *LHComponent
	RevPrimer *LHComponent
	MasterMix *LHComponent
	PCRPolymerase *LHComponent
	Template *LHComponent
	OutPlate *LHPlate
)

// Physical outputs from this protocol Lessonwith types
Outputs (
	Reaction *LHComponent
)

Requirements {
}

// Conditions to run on startup
Setup {
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {

	// rename components

	Template.CName = TemplateName
	FwdPrimer.CName = FwdPrimerName
	RevPrimer.CName = RevPrimerName

	var allVolumes []Volume

	allVolumes = append(allVolumes, MasterMixVolume, Templatevolume)

	if !PrimersalreadyAddedtoMasterMix {
		allVolumes = append(allVolumes, FwdPrimerVol, RevPrimerVol)
	}

	if !PolymeraseAlreadyaddedtoMastermix {
		allVolumes = append(allVolumes, PolymeraseVolume)
	}

	// calculate volume of water to add
	waterVol := wunit.SubtractVolumes(TotalReactionVolume, allVolumes)

	var mastermix *LHComponent
	// Top up with reaction buffer if necessary.
	if waterVol.GreaterThan(wunit.NewVolume(0.5, "ul")) {
		waterSample := mixer.Sample(ReactionBuffer, waterVol)
		mastermix = MixInto(OutPlate, WellPosition, waterSample)
	}

	// Make a mastermix

	mmxSample := mixer.Sample(MasterMix, MasterMixVolume)

	// pipette out to make mastermix
	if mastermix != nil {
		mastermix = Mix(mastermix, mmxSample)
	} else {
		mastermix = MixInto(OutPlate, WellPosition, mmxSample)
	}

	// rest samples to zero
	samples := make([]*LHComponent, 0)

	// if this is false do stuff inside {}

	// add primers

	if !PrimersalreadyAddedtoMasterMix {
		FwdPrimerSample := mixer.Sample(FwdPrimer, FwdPrimerVol)
		samples = append(samples, FwdPrimerSample)
		RevPrimerSample := mixer.Sample(RevPrimer, RevPrimerVol)
		samples = append(samples, RevPrimerSample)
	}

	// add template
	templateSample := mixer.Sample(Template, Templatevolume)
	samples = append(samples, templateSample)

	for j := range samples {
		if !PolymeraseAlreadyaddedtoMastermix && j == len(samples)-1 {
			samples[j].Type = wtype.LTPostMix
		}
		mastermix = Mix(mastermix, samples[j])
	}
	reaction := mastermix

	// this needs to go after an initial denaturation!
	if !PolymeraseAlreadyaddedtoMastermix {

		polySample := mixer.Sample(PCRPolymerase, PolymeraseVolume)
		polySample.Type = wtype.LTPostMix

		reaction = Mix(reaction, polySample)
	}

	// thermocycle parameters called from enzyme lookup:

	polymerase := PCRPolymerase.CName

	extensionTemp := enzymes.DNApolymerasetemps[polymerase]["extensiontemp"]
	meltingTemp := enzymes.DNApolymerasetemps[polymerase]["meltingtemp"]

	var pcrSteps []string

	initialDenat := fmt.Sprint("Initial Denaturation: ", meltingTemp.ToString(), " for ", InitDenaturationtime.ToString())

	cycles := fmt.Sprint(Numberofcycles, " cycles of : ")

	spacer := "***"

	denat := fmt.Sprint("Denature: ", meltingTemp.ToString(), " for ", Denaturationtime.ToString())

	anneal := fmt.Sprint("Anneal: ", AnnealingTemp.ToString(), " for ", Annealingtime.ToString())

	extend := fmt.Sprint("Extension: ", extensionTemp.ToString(), " for ", Extensiontime.ToString())

	spacer = "***"

	finalExtension := fmt.Sprint(" Then Final Extension: ", extensionTemp.ToString(), " for ", Finalextensiontime.ToString())

	// all done
	Reaction = reaction //r1

	Reaction.CName = ReactionName

	message := "Put Reactions in ThermoCycler with following cycle conditions. Return to deck once PCR has finished if running DNA_Gel"

	pcrSteps = append(pcrSteps, initialDenat, cycles, spacer, denat, anneal, extend, spacer, finalExtension, message)

	thermocycleMessage := strings.Join(pcrSteps, ";")

	Reaction = MixerPrompt(Reaction, thermocycleMessage)
}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
}

/*type Polymerase struct {
	LHComponent
	Rate_BPpers float64
	Fidelity_errorrate float64 // could dictate how many colonies are checked in validation!
	Extensiontemp Temperature
	Hotstart bool
	StockConcentration Concentration // this is normally in U?
	TargetConcentration Concentration
	// this is also a glycerol solution rather than a watersolution!
}
*/
