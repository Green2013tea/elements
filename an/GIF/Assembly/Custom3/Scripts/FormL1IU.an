// Protocol FormL1TU
//
// This is to make a L1 part for a switch. It is denoted as an integrase Unit, IU

protocol FormL1IU

// Place golang packages to import here
import (
	"bytes"
)

func MakeL1IU(ID string, L0Parts []Part)(Part){

	att := RestrictionSite{ID : "tp901", class: "ATT", seq : []string{"ATGCCAACACAATTAACATCTCAATCAAGGTAAATGCTTTTTGCTTTTTTTGC","AAAGGAGTTTTTTAGTTACCTTAATTGAAATAAACGAAATAAAAACTCGC"}} //attb,attp

	// Forms an Integrase switch unit for restriction
	// this needs to be a separate element with more options

	//placeholder for the switch
	_L1PartSeq := make([]string, 4)

	//forming the sequence array

	for u := range L0Parts {
		switch {
			case L0Parts[u].class == "RBS":
				_L1PartSeq[0] = ReverseDNA(L0Parts[u].seq)
				L0Parts[u].position = 1
				//reversing the RBS sequence for the 5' 3'
				_L1PartSeq[2] = L0Parts[u].seq

			case L0Parts[u].class == "P":
				L0Parts[u].position = 2
				_L1PartSeq[1] = L0Parts[u].seq

			case L0Parts[u].class =="CDS":
				L0Parts[u].position = 4
				_L1PartSeq[3] = L0Parts[u].seq
		}
	}

	//concatenate seq
	var buffer bytes.Buffer
	buffer.WriteString(_L1PartSeq[0])
	buffer.WriteString(att.seq[0])
	buffer.WriteString(_L1PartSeq[1])
	buffer.WriteString(att.seq[1])
	buffer.WriteString(_L1PartSeq[2])
	buffer.WriteString(_L1PartSeq[3])

	L1PartSeq := buffer.String()

	L1PartA := Part{ID: ID, level: 1, class: "SW", seq: L1PartSeq , position: 0}

	return L1PartA
}

// Parameters to this protocol
Parameters (
	ID			string
	L0PartsA_In	[]Part
)

// Output data of this protocol
Data (
    L0PartsA_Out    	[]Part
    L1PartsA_Out    	[]Part
)

// Conditions to run on startup
Setup {
}

// The core process for this protocol. These steps are executed for each input.
Steps {

	L1PartA := MakeL1IU(ID, L0PartsA_In)
	//putting it in a slice to homogenize passed data. We still return only one L1 Part
	L1PartsA_Out = []Part{L1PartA}


}

// Run after controls and a steps block are completed to post process any data
// and provide downstream results
Analysis {

}

// A block of tests to perform to validate that the sample was processed
// correctly. Optionally, destructive tests can be performed to validate
// results on a dipstick basis
Validation {

}
