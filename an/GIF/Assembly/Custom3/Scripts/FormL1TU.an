// Protocol FormL1TU
//
// This is to make a L1 part with classical P-RBS-CDS-T, a transcription unit

protocol FormL1TU

// Place golang packages to import here
import (
	"bytes"
)

func FormL1TU(ID string, L0Parts []Part)(Part) {

	// Forms a L1 Transcription unit (TU), with classical Promoter, RBS, CDS, T order

	//placeholder for the TU
	_L1PartSeq := make([]string, 4)

	//assigning the positions to L0Parts

	for u := range L0Parts {
		switch L0Parts[u].class{
			case "P":
				L0Parts[u].position = 1
				_L1PartSeq[0] = L0Parts[u].seq
			case "RBS":
				L0Parts[u].position = 2
				_L1PartSeq[1] = L0Parts[u].seq
			case "CDS":
				L0Parts[u].position = 3
				_L1PartSeq[2] = L0Parts[u].seq
			case "T":
				L0Parts[u].position = 4
				_L1PartSeq[3] = L0Parts[u].seq
		}
	}

	//concatenate seq
	var buffer bytes.Buffer
	buffer.WriteString(_L1PartSeq[0])
	buffer.WriteString(_L1PartSeq[1])
	buffer.WriteString(_L1PartSeq[2])
	buffer.WriteString(_L1PartSeq[3])

	L1PartSeq := buffer.String()

	L1Part := Part{ID: ID, level: 1, class: "TU", seq: L1PartSeq, position: 0}

	return L1Part
}

// Parameters to this protocol
Parameters (
	ID			string
	L0PartsA_In	[]Part
)

// Output data of this protocol
Data (
    L0PartsA_Out    	[]Part
    L1PartsA_Out    	[]Part
)

// Conditions to run on startup
Setup {
}

// The core process for this protocol. These steps are executed for each input.
Steps {

	L1PartA := FormL1TU(ID, L0PartsA_In)
	//putting it in a slice to homogenize passed data. We still return only one L1 Part
	L1PartsA_Out = []Part{L1PartA}

}


// Run after controls and a steps block are completed to post process any data
// and provide downstream results
Analysis {

}

// A block of tests to perform to validate that the sample was processed
// correctly. Optionally, destructive tests can be performed to validate
// results on a dipstick basis
Validation {

}
