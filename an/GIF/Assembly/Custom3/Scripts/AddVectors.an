// Protocol FormL1TU
//
// This is to make a L1 part for a switch. It is denoted as an integrase Unit, IU

protocol AddVectors

import "bytes"

func AddVector(partsB []Part) []Part{

	//add vector to the part. It does so on the 5' end.

	//Parts with overhang added slice.
	//A = base DNA
	//B = Overhangs added
	//C = Vectors added (transform ready)
	var partsC []Part

	//placeholder for partC
	var _partC Part

	//placeholder for partC seq
	var _partCSeq string

	//extract vectors from the slice of parts
	vectors := SelectPartsFromClass(partsB, "V")

	//for each parts, add the correct vector according to level
	for o := range partsB{
		for k := range vectors {
			switch {
				case vectors[k].level == partsB[o].level:

					var buffer bytes.Buffer

					buffer.WriteString(partsB[0].seq)
					buffer.WriteString(vectors[k].seq)

					_partCSeq = buffer.String()

					_partC = Part{partsB[0].ID, partsB[o].level, partsB[o].class, _partCSeq, 0}
					partsC = append(partsC, _partC)

				default:
					continue
			}
		}
	}

	return partsC
}

// Parameters to this protocol
Parameters (
	PartsB_In	[]Part
)

// Output data of this protocol
Data (
	PartsC_Out		[]Part
)

// Conditions to run on startup
Setup {
}

// The core process for this protocol. These steps are executed for each input.
Steps {

	PartsC_Out = AddVector(PartsB_In)

}

// Run after controls and a steps block are completed to post process any data
// and provide downstream results
Analysis {

}

// A block of tests to perform to validate that the sample was processed
// correctly. Optionally, destructive tests can be performed to validate
// results on a dipstick basis
Validation {

}
