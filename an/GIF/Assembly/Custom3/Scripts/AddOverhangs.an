// Protocol FormL1TU
//
// This is to make a L1 part for a switch. It is denoted as an integrase Unit, IU

protocol AddOverhangs

import (
	"bytes"
	"fmt"
)

func AddOverhangs(partsA []Part)([]Part) {

	//select which overhang library to use

	//only 3parts for now

	//Parts with overhang added slice.
	//A = base DNA
	//B = Overhangs added
	//C = Vectors added (transform ready)
	var partsB []Part

	//3' and 5' ends variables to hold the overhangs
	var threePrime string
	var fivePrime string
	//placeholder for the partB object to append to the returned slice
	var _partB Part
	//placeholder for the new sequence
	var _newSeq string

	//function to append given string to seq
	appendOverhangs := func (threePrime string, fivePrime string, seq string) string {

		var buffer bytes.Buffer
		buffer.WriteString(threePrime)
		buffer.WriteString(seq)
		buffer.WriteString(fivePrime)

		return buffer.String()
	}

	//adding the correct overhangs

	for y := range partsA {
		switch partsA[y].position{
			case 1:

				threePrime = overhangLib[partsA[y].level]["L1Uadaptor + Pro"][0]
				fivePrime = overhangLib[partsA[y].level]["L1Uadaptor + Pro"][1]

				_newSeq = appendOverhangs(threePrime, fivePrime, partsA[y].seq)
				_partB = Part{partsA[y].ID, partsA[y].level, partsA[y].class, _newSeq, partsA[y].position}

				partsB = append(partsB, _partB)

			case 2:
				threePrime = overhangLib[partsA[y].level]["L1Uadaptor + Pro"][0]
				fivePrime = overhangLib[partsA[y].level]["L1Uadaptor + Pro"][1]

				_newSeq = appendOverhangs(threePrime, fivePrime, partsA[y].seq)

				_partB = Part{partsA[y].ID, partsA[y].level, partsA[y].class, _newSeq, partsA[y].position}

				partsB = append(partsB, _partB)

			case 3:
				threePrime = overhangLib[partsA[y].level]["L1Uadaptor + Pro"][0]
				fivePrime = overhangLib[partsA[y].level]["L1Uadaptor + Pro"][1]

				_newSeq = appendOverhangs(threePrime, fivePrime, partsA[y].seq)

				_partB = Part{partsA[y].ID, partsA[y].level, partsA[y].class, _newSeq, partsA[y].position}

				partsB = append(partsB, _partB)

		}
	}

	return partsB
}


// Parameters to this protocol
Parameters (
	PartsA_In	[]Part
)

// Output data of this protocol
Data (
	PartsB_Out		[]Part
)

// Conditions to run on startup
Setup {
}

// The core process for this protocol. These steps are executed for each input.
Steps {

	fmt.Println(PartsA_In[0].ID)

	PartsB_Out = AddOverhangs(PartsA_In)

}

// Run after controls and a steps block are completed to post process any data
// and provide downstream results
Analysis {

}

// A block of tests to perform to validate that the sample was processed
// correctly. Optionally, destructive tests can be performed to validate
// results on a dipstick basis
Validation {

}
