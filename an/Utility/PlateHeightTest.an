// Protocol to allow for rapid combinatorial testing of plate, liquid class combinations.
// Allows testing of effect of liquid handling changes such as offsets and liquid class changes
// Intended to be run prior to any liquid handling change before accepting pull requests.
// The element creates an output csv file which can be filled in by the user to log observed offsets
// for each condition
protocol PlateTest

import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"github.com/antha-lang/antha/microArch/factory"
	"github.com/antha-lang/antha/microArch/driver/liquidhandling"
	"fmt"
	"github.com/antha-lang/antha/cmd/antharun/cmd"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/search"

	"encoding/csv"
	"os"
	//"path/filepath"
	"time"

)

// Input parameters for this protocol (data)
Parameters (
	TestName string // name of test e.g. branch name, date, name of project; csv file will be named after this
	Liquidname string // can be whatever you want to call it
	LiquidVolumes []Volume // List of volumes to test
	LiquidTypes []string // corresponding to valid antha liquid types
	OutPlates []string // list of out plate types to test
	WellsUsedperOutPlateInorder []int // optional slice of ints which should match the length and order of the OutPlates slice

)

// Data which is returned from this protocol, and data types
Data (
	Status string
	WellsUsedPostRunPerPlate []int
	PlatesUsedPostRunPerPlateType []int
)


// Physical Inputs to this protocol with types
Inputs (
	Startingsolution *wtype.LHComponent
	
)

// Physical outputs from this protocol with types
Outputs (
	FinalSolutions []*wtype.LHComponent
	
)

Requirements {
	
}

// Conditions to run on startup
Setup {
	
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	

	// prepare header to add data and export csv
	
	if TestName == "" && len(OutPlates)>=2{
		TestName = "PlateHeightTest" +fmt.Sprint(time.Now().Format("20060102150405"))
	}else if TestName == "" && len(OutPlates)== 1 {
		TestName = "PlateHeightTest" + OutPlates[0]+fmt.Sprint(time.Now().Format("20060102150405"))
	}else {
	TestName = TestName +fmt.Sprint(time.Now().Format("20060102150405"))
	}
	outputfilename := TestName+".csv"
	
	csvfile, err := os.Create(outputfilename)
	if err != nil {
		Errorf(err.Error())
	}
	
	defer csvfile.Close()
	
	records := make([][]string,0)
	
	title := []string{"Plate Height Test:",TestName}
	time := []string{"Time:",fmt.Sprint(time.Now())}
	
	// find git commit id
	anthacommit, err := cmd.GitCommit()
	
	if err != nil{
		Errorf(err.Error())
	}
	
	gitcommit := []string{"antha-lang/antha commitID:",anthacommit}
	
	spacer := []string{}
	
	header := []string{"TestName", "Plate","Liquid name", "Liquid type ","Liquid Volume", "Well ","Aspirate mm from Bottom of well? ","Dispense mm from Bottom of well? ", "Acceptable? ", " Comments", "plate Z start","Plate Height","lhpolicy aspirate z offset","lhpolicy dispense z offset"}
	records = append(records,title,time,gitcommit,spacer,header)
	
	

	// Make slices to fill up later before exporting as outputs
	FinalSolutions = make([]*wtype.LHComponent,0)
	WellsUsedPostRunPerPlate = make([]int,0)
	PlatesUsedPostRunPerPlateType = make([]int,0)
	

	// Get list of plates to check validity of plate names specified in parameters
	platelist := factory.GetPlateList()
	
	// This if statement ensures that default behaviour should be to assume that
	// all plates have no wells used if no WellsUsedperPlateTypeInorder []int is specified
	// in input parameters
	if WellsUsedperOutPlateInorder == nil || len(WellsUsedperOutPlateInorder)==0{
		WellsUsedperOutPlateInorder = make([]int,len(OutPlates))
		for l := range OutPlates {
			WellsUsedperOutPlateInorder[l] = 0
		}
	}
	
	// Range through all plates first 
	for k := range OutPlates {
		
		// set plate number to 1 to start with
		var platenumber int = 1
		
		// get all well positions from the plate
		
		lhplate := factory.GetPlateByType(OutPlates[k])
		
		wellpositionsarray := lhplate.AllWellPositions(wtype.BYCOLUMN)
		
		
		// Initialise a counter to be equal to the number of wells used for that plate
		// The counter will be used to select the correct well position
		// if no well position is specified the scheduler will by default select the next well position
		// however using the counter gives flexibility to resume from a given well position if  
		// a plate is already partially filled
		counter := WellsUsedperOutPlateInorder[k]
		
		// range through different volumes to ensure correct behaviour with different pipette heads
		// recommended defaults would be "5ul" and "100"
		for j := range LiquidVolumes {
			
			// range through liquid types
			for i := range LiquidTypes {
				
				liquidtypestring, err := wtype.LiquidTypeFromString(LiquidTypes[i])
				
				// check liquid type is valid
				if err != nil {
					Errorf("Liquid type issue with ", LiquidTypes[i], err.Error())
				}
				
				// change liquid type to that specified in loop
				Startingsolution.Type = liquidtypestring
				
				// sample 
				sample := mixer.Sample(Startingsolution,LiquidVolumes[j]) 
				
				// check validity of plate name; is it in the plate factory?
				if !search.InSlice(OutPlates[k],platelist){
					Errorf("No plate ", OutPlates[k], " found in library ", platelist)
				}
				
				// Mix into a plate at next well position, plate name is given as the type of plate + platenumber
				
				platename := fmt.Sprint(OutPlates[k],"_Platenumber_",platenumber)
				
				finalSolution := MixNamed(OutPlates[k], wellpositionsarray[counter],platename,sample)
				FinalSolutions = append(FinalSolutions,finalSolution)
	
			// Append status
			Status = Status + fmt.Sprintln(LiquidVolumes[j].ToString(), " of ",Liquidname, "Liquid type ", LiquidTypes[i],"was mixed into " + OutPlates[k])
			
			// get specific plate info
	
	
			plateheight := lhplate.Height
			zstart := lhplate.WellZStart
	/*
	Height float64
	WellXOffset float64            // distance (mm) between well centres in X direction
	WellYOffset float64            // distance (mm) between well centres in Y direction
	WellXStart  float64            // offset (mm) to first well in X direction
	WellYStart  float64            // offset (mm) to first well in Y direction
	WellZStart  float64            // offset (mm) to bottom of well in Z direction
	*/ 
			// get lhpolicyinfo
			
			// print out LHPolicy info
			policy, ok := liquidhandling.GetPolicyByName(LiquidTypes[i])
			
			if !ok {
				Errorf(fmt.Sprint("Liquid type, ",LiquidTypes[i], "not found"))
			}
			
			
			aspz := policy["ASPZOFFSET"]
			dspz := policy["DSPZOFFSET"]
			
			record := []string{TestName,platename,Liquidname,LiquidTypes[i],LiquidVolumes[j].ToString(),wellpositionsarray[counter],  "  ","  "," "," ",fmt.Sprint(zstart),fmt.Sprint(plateheight),fmt.Sprint(aspz),fmt.Sprint(dspz)}
			records = append(records, record)

			// evaluate whether plate is full and if so add new plate
			if counter +1 == len(wellpositionsarray) {
			platenumber++
			counter=0
			// else increase counter ready for next instance of loop
			}else{
			counter++
			}
			
			}
		}
		
		// export wells used once all aspirate and dispenses for a particular plate type
		// sticking to plate order specified in input parameters
		WellsUsedPostRunPerPlate = append(WellsUsedPostRunPerPlate,counter)
		
		if counter > 0 {
		PlatesUsedPostRunPerPlateType = append(PlatesUsedPostRunPerPlateType,platenumber)
		}else {
		PlatesUsedPostRunPerPlateType = append(PlatesUsedPostRunPerPlateType,platenumber-1)

		}
	}
	

	csvwriter := csv.NewWriter(csvfile)

	for _, record := range records {

		err = csvwriter.Write(record)

		if err != nil {
			Errorf(err.Error())
		}
	}
	csvwriter.Flush()



	
	
}
// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
	
}
