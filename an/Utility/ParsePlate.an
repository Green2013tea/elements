// example protocol for parsing the contents of a plate from a csv file
protocol ParsePlate
import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	inplate "github.com/antha-lang/antha/target/mixer"
)
// Input parameters for this protocol (data)
Parameters (
	InputCSVfile string
) 
// Data which is returned from this protocol, and data types
Data (
	Error error
)


// Physical Inputs to this protocol with types
Inputs (
   
) 
// Physical outputs from this protocol with types
Outputs (
	AllComponents []*wtype.LHComponent//Gel
	PlatewithComponents *wtype.LHPlate
	ComponentMap map[string]*wtype.LHComponent
   
)

// No special requirements on inputs
Requirements {
  
}

// Condititions run on startup
// Including configuring an controls required, and the blocking level needed
// for them (in this case, per plate of samples processed)
Setup {

}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {

	// parse sample locations from file
	inputplate,err := inplate.ParseInputPlateFile(InputCSVfile) 
	
	if err != nil {
		Error = err
		Errorf(err.Error())
	}
	
		
	components := make([]*wtype.LHComponent,0)
	ComponentMap = make(map[string]*wtype.LHComponent)
	

	for _, wellcontents := range inputplate.AllWellPositions(wtype.BYCOLUMN){
	
	if !inputplate.WellMap()[wellcontents].Empty() {
	
	component := inputplate.WellMap()[wellcontents].WContents
	components = append(components, component)
	ComponentMap[component.CName] = component
	
		}
	}
	AllComponents = components
	PlatewithComponents = inputplate
	SetInputPlate(PlatewithComponents)

}
	


// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
    // need the control samples to be completed before doing the analysis

    //

}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
  /* 	if calculatedbandsize == expected {
		stop
	}
	if calculatedbandsize != expected {
	if S == "matches size of incorrect assembly possibility" {
		call(assembly_troubleshoot)
		}
	} // loop at beginning should be designed to split labware resource optimally in the event of any failures e.g. if 96well capacity and 4 failures check 96/4 = 12 colonies of each to maximise chance of getting a hit
    }
    if repeat > 2
	stop
    }
    if (recoverylocation doesn't grow then use backup or repeat 
	}
	if sequencingresults do not match expected then use backup or repeat
    // TODO: */
}

//func cherrypick ()
