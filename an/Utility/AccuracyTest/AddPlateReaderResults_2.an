// Protocol to parse plate reader results and match up with a plate set up by the accuracy test. 
// Some processing is carried out to:
// A: Plot expected results (based on mathematically diluting the stock concentration) vs actual (measured concentrations from beer-lambert law, A = Îµcl)
// B: Plot volume by correctness factor (Actual conc / Expected conc)
// C: Plot Actual conc vs correctness factor
// D: Plot run order vs correctness factor
// E: Calculate R2
// F: Calculate Coefficent of variance for each pipetting volume
// G: Validate results against success thresholds for R2 and %CV
// Additional optional features will return 
// (1) the wavelength with optimal signal to noise for an aborbance spectrum
// (2) Comparision with manual pipetting steps
protocol AddPlateReaderresults_2

import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/montanaflynn/stats"
	"github.com/antha-lang/antha/microArch/factory"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/Pubchem"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/buffers"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/Parser"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/doe"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/plot"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/platereader"
	"math"
	"fmt"
	"path/filepath"
	"strconv"
	"strings"
	"time"
	"bytes"
)


// Input parameters for this protocol (data)
Parameters (
	MarsResultsFileXLSX File // input file containing the Plate reader results exported from Mars
	DesignFile File // Design file for the executed experiment containing the corresponding plate and well locations

	SheetNumber         int    // i.e. the sheet position in the plate reader results excel file; starting from 0                                      
	DesignFiletype      string // current supported formats are "JMP" and "DX"
	OutputFilename      string // set the desired name for the output file, if this is blank it will append the design file name with _output

	Wavelength          int   //  Wavelength to use for calculations, should match up with extinction coefficient for molecule of interest 
	Extinctioncoefficient float64 // extinction coefficient for target Molecule at the specified wavelength; e.g. 20330 for tartrazine at 472nm
	StockconcinMperL Concentration //= 0.0002878191305957933
	
	ReadingTypeinMarsFile string // This should match the label in the header for each column in the plate reader result file, e.g. "Abs Spectrum"

	Blanks []string /// wells of the blank sample locations on the plate

	FindOptWavelength   bool    // whether the scan should be used to return the wavelength with maximum signal to noise found
	WellForScanAnalysis string // well used for finding wavelength with optimal signal to noise. This is ignored if FindOptWavelength is set to false

	Responsecolumntofill string // name your response

	ManualComparison      bool  //  Option to compare to manual pipetting
	VolumeToManualwells map[string][]string // if comparing to manual pipetting set the wells to use for each concentration here
	Stockvol Volume // volume of diluent per well
	StockEqualsTotalVolPerWell bool // if true the StockVol represents the total volume per well instead of a fixed volume which the test solution was added to
	
	// validation requirements
	R2threshold float64 // set a threshold above which R2 will pass; 0 = 0%, 1 = 100%; e.g. 0.7 = 70%
	CVthreshold float64 // set a threshold below which CV will pass; 0 = 0%, 1 = 100%; e.g. 0.2 = 20%
)

// Data which is returned from this protocol, and data types
Data (
	OutPutDesignFile File
	ActualVsExpectedPlot File
	CorrectnessFactorPlot File
	BlankValues []float64
	ResponsetoManualValuesmap map[string][]float64
	MeasuredOptimalWavelength int
	Runs []doe.Run
	R2 float64
	Variance float64
	Formula string
	R2_CorrectnessFactor float64
	R2Pass bool
	CV float64
	CVpass bool
	Errors []string
	VolumeToActualConc map[string]Dataset
	VolumeToCorrectnessFactor map[string]Dataset
)


// Physical Inputs to this protocol with types
Inputs (
	Molecule *LHComponent
	Diluent *LHComponent
	PlateType *LHPlate
)

// Physical outputs from this protocol with types
Outputs (

)

Requirements {
}

// Conditions to run on startup
Setup {
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	
	if OutputFilename == "" {
		
		_, filename := filepath.Split(DesignFile.Name)
		
		OutputFilename = strings.Split(filename,".")[0] + "_output" +fmt.Sprint(time.Now().Format("20060102150405")) +".xlsx"
	}
	
	var actualconcentrations = make(map[string]Concentration)
	ResponsetoManualValuesmap = make(map[string][]float64)

	molecule, err := pubchem.MakeMolecule(Molecule.CName)
	if err != nil {
		Errorf(err.Error())
	}
	
	Molecularweight := molecule.MolecularWeight
		
	data, err := MarsResultsFileXLSX.ReadAll()

	if err != nil {
		Errorf("Error reading Mars file %s", err.Error())
	}

	marsdata, err := parser.ParseMarsXLSXBinary(data,SheetNumber)
	if err != nil {
		Errors = append(Errors,err.Error())
		Errorf(err.Error())
	}

	// range through pairing up wells from mars output and doe design
	
	var runs []doe.Run
	
	// find out int factors from liquidhandling policies
	policyitemmap := wtype.MakePolicyItems()
	intfactors := make([]string, 0)

	for key, val := range policyitemmap {

		if val.Type.Name() == "int" {
			intfactors = append(intfactors, key)
		}
	}

	designFileData, err := DesignFile.ReadAll()

	if err != nil {
		Errorf("Error reading Design file %s", err.Error())
	}

	if DesignFiletype == "DX" {
		runs, err = doe.RunsFromDXDesignContents(designFileData, intfactors)
		if err != nil {
			panic(err)
		}
	} else if DesignFiletype == "JMP" {
		runs, err = doe.RunsFromJMPDesignContents(designFileData, []int{}, []int{}, intfactors)
		if err != nil {
			panic(err)
		}
	}
	BlankValues = make([]float64,0)
	
	
	for i := range Blanks {
	blankValue, err := marsdata.ReadingsAsAverage(Blanks[i], 1, Wavelength, ReadingTypeinMarsFile)
	if err != nil {
		Errorf(fmt.Sprint("blank sample not found. ", err.Error()))
	}
	BlankValues = append(BlankValues,blankValue)
	}

	runswithresponses := make([]doe.Run, 0)


	for k, run := range runs {

		// values for r2 to reset each run

		//xvalues := make([]float64, 0)
		//yvalues := make([]float64, 0)

		// add origin
		//xvalues = append(xvalues, 0.0)
		//yvalues = append(yvalues, 0.0)

			var samples []string
			var manualsamples []string
			var ManualValues = make([]float64,0)
			var manual float64
			var absorbance wtype.Absorbance
			var manualabsorbance wtype.Absorbance
			//var actualconcreplicates = make([]float64, 0)
			var manualCorrectnessFactorValues = make([]float64,0)
			var correctnessFactorValues = make([]float64,0)

			experimentalvolumeinterface, err := runs[k].GetAdditionalInfo("Volume") 
			
			experimentalvolumestr :=  experimentalvolumeinterface.(string)
			
			//experimentalvolumestr = strings.TrimSpace(experimentalvolumestr)
			
			var volandunit []string
			
			if strings.Count(experimentalvolumestr," ")==1{
			volandunit = strings.Split(experimentalvolumestr, " ")
			}else if strings.Count(experimentalvolumestr,"ul")==1 && strings.HasSuffix(experimentalvolumestr,"ul"){
				volandunit = []string{strings.Trim(experimentalvolumestr,"ul"),"ul"}
			}
			
			vol,err := strconv.ParseFloat(strings.TrimSpace(volandunit[0]), 64)
			
			if err != nil {
			Errorf(err.Error())
			}
	
			experimentalvolume := wunit.NewVolume(vol,strings.TrimSpace(volandunit[1]))
			
			
			actualconcentrations[experimentalvolume.ToString()] = buffers.DiluteBasedonMolecularWeight(Molecularweight, StockconcinMperL, experimentalvolume, Diluent.CName, wunit.SubtractVolumes(Stockvol, []Volume{experimentalvolume}))
	

			//locationHeaders := ResponsetoLocationMap[response]

			//  manual pipetting well
			if wellsmap, ok := VolumeToManualwells[experimentalvolumestr]; ManualComparison && ok {

				
				manualwell := wellsmap[0] // 1st well of array only

				manual, err = marsdata.ReadingsAsAverage(manualwell, 1, Wavelength, ReadingTypeinMarsFile)

				if err !=nil {
					Errorf(err.Error())
				}

				

				manualsamples = VolumeToManualwells[experimentalvolumestr]
				
				for i:= range manualsamples {
				manualvalue, err := marsdata.ReadingsAsAverage(manualsamples[i], 1, Wavelength, ReadingTypeinMarsFile)
				
				if err !=nil {
					Errorf(err.Error())
				}
				
				ManualValues = append(ManualValues,manualvalue)
				}
				
				ResponsetoManualValuesmap[experimentalvolumestr] = ManualValues
				
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" Manual Raw average "+strconv.Itoa(Wavelength), manual)
				
			} else if ManualComparison {
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" Manual Raw average "+strconv.Itoa(Wavelength), 0.0)
			}
			

			// then per replicate ...

			//for i, locationheader := range locationHeaders {
				well, err := runs[k].GetAdditionalInfo("Location")
				if err != nil {
					panic(err)
				}

				// check optimal difference for each well
				if FindOptWavelength {
					MeasuredOptimalWavelength, err = marsdata.FindOptimalWavelength(WellForScanAnalysis, Blanks[0], "Raw Data")
					
					if err!= nil {
						Errorf(fmt.Sprint("Error found with well for scan analysis: ", err.Error()))
					}
				}

				
				rawaverage, err := marsdata.ReadingsAsAverage(well.(string), 1, Wavelength, ReadingTypeinMarsFile)

				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" Raw average "+strconv.Itoa(Wavelength), rawaverage)

				// blank correct

				samples = []string{well.(string)}

				blankcorrected, err := marsdata.BlankCorrect(samples, Blanks, Wavelength, ReadingTypeinMarsFile)
				
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" BlankCorrected "+strconv.Itoa(Wavelength), blankcorrected)

				// path length correct
				var volused Volume
				if StockEqualsTotalVolPerWell {
					volused = Stockvol 
				}else{
					volused = wunit.AddVolumes([]Volume{Stockvol, experimentalvolume})
				}
				pathlength, err := platereader.EstimatePathLength(factory.GetPlateByType(PlateType.Type), volused)

				if err != nil {
					panic(err)
				}
			
				
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" pathlength "+strconv.Itoa(Wavelength), pathlength.ToString())

				absorbance.Reading = blankcorrected

				pathlengthcorrect := platereader.PathlengthCorrect(pathlength, absorbance)
				
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" Pathlength corrected "+strconv.Itoa(Wavelength), pathlengthcorrect.Reading)

				// molar absorbtivity of tartazine at 472nm is 20330
				// http://www.biochrom.co.uk/faq/8/119/what-is-the-limit-of-detection-of-the-zenyth-200.html

				actualconc := platereader.Concentration(pathlengthcorrect, Extinctioncoefficient)

				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+"ActualConc", actualconc.SIValue())

				// calculate correctness factor based on expected conc

				expectedconc := actualconcentrations[experimentalvolume.ToString()]
				correctnessfactor := actualconc.SIValue() / expectedconc.SIValue()

				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" ExpectedConc "+strconv.Itoa(Wavelength), expectedconc.SIValue())
				
				// if Infinity or Not a number set to 0
				if math.IsInf(correctnessfactor,0) || math.IsNaN(correctnessfactor){
					correctnessfactor = 0.0
				}
				
				run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" CorrectnessFactor "+strconv.Itoa(Wavelength), correctnessfactor)

				
				correctnessFactorValues = append(correctnessFactorValues,correctnessfactor)
							
				// add comparison to manually pipetted wells
				if _, ok := VolumeToManualwells[experimentalvolumestr]; ManualComparison && ok  {
					manualblankcorrected, err := marsdata.BlankCorrect(manualsamples, Blanks, Wavelength, ReadingTypeinMarsFile)
					if err != nil {
						Errorf(err.Error())
					}
					manualabsorbance.Reading = manualblankcorrected
					manualpathlengthcorrect := platereader.PathlengthCorrect(pathlength, manualabsorbance)
					manualactualconc := platereader.Concentration(manualpathlengthcorrect, Extinctioncoefficient)
					manualcorrectnessfactor := actualconc.SIValue() / manualactualconc.SIValue()
					manualCorrectnessFactorValues = append(manualCorrectnessFactorValues,manualcorrectnessfactor)
				
					run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+"ManualActualConc", manualactualconc.SIValue())
					run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" ManualCorrectnessFactor "+strconv.Itoa(Wavelength), manualcorrectnessfactor)
				} else if ManualComparison {
					run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+"ManualActualConc", 0.0)
					run = doe.AddNewResponseFieldandValue(run, Responsecolumntofill+" ManualCorrectnessFactor "+strconv.Itoa(Wavelength),  0.0)
					
				}


		run = doe.AddNewResponseFieldandValue(run, "Runorder", k)


		runswithresponses = append(runswithresponses, run)
	}
	
	xlsxfile := doe.XLSXFileFromRuns(runswithresponses,OutputFilename,DesignFiletype)
	
	Runs = runswithresponses

	var buffer bytes.Buffer
	
	xlsxfile.Write(&buffer)

	OutPutDesignFile.Name = OutputFilename

	OutPutDesignFile.WriteAll(buffer.Bytes())
	
}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
	
	Errors = make([]string,0)
	
		xvalues := make([]float64, 0)
		yvalues := make([]float64, 0)

		// add origin
		xvalues = append(xvalues, 0.0)
		yvalues = append(yvalues, 0.0)
	
	fmt.Println("in analysis")
	
	if len(Runs)==0{
		Errorf("no runs")
	}
	// 1. now calculate r2 and plot results
	for i,runwithresponses := range Runs {
		// values for r2 to reset each run

	// get response value and check if it's a float64 type
	expectedconc, err := runwithresponses.GetResponseValue("Absorbance ExpectedConc "+strconv.Itoa(Wavelength))
	
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	expectedconcfloat,floattrue := expectedconc.(float64)
	// if float64 is true 
	if floattrue {
		xvalues = append(xvalues, expectedconcfloat)
	}else {
		Errorf("Run"+fmt.Sprint(i,runwithresponses)+" ExpectedConc:"+fmt.Sprint(expectedconcfloat))
	}

	// get response value and check if it's a float64 type
	actualconc, err := runwithresponses.GetResponseValue("AbsorbanceActualConc")
	
	if err != nil{
		fmt.Println(err.Error())
		Errors = append(Errors,err.Error())
	}
	
	actualconcfloat,floattrue := actualconc.(float64)
	
	if floattrue {
		yvalues = append(yvalues,actualconcfloat )
	}else {
		fmt.Println(err.Error())
		Errorf(" ActualConc:"+fmt.Sprint(actualconcfloat))
	}
		
	}
		
		
	R2,Variance,Formula = plot.Rsquared("Expected Conc", xvalues, "Actual Conc", yvalues)
	//run.AddResponseValue("R2", rsquared)

	xygraph, err := plot.Plot(xvalues, [][]float64{yvalues})
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	plot.AddAxesTitles(xygraph, "Expected Conc M/l", "Measured Conc M/l")
			
	xygraph.Title.Text = Molecule.CName + ": Expected vs Measured Concentration"
			
	filenameandextension := strings.Split(OutputFilename, ".")
	
	ActualVsExpectedPlot, err =  plot.Export(xygraph, "20cm","20cm",filenameandextension[0]+"_plot"+".png")
	
	if err != nil{
		Errors = append(Errors,err.Error())
		Errorf(err.Error())
	}
	
	// reset
		xvalues = make([]float64, 0)
		yvalues = make([]float64, 0)

		// add origin
		xvalues = append(xvalues, 0.0)
		yvalues = append(yvalues, 0.0)
	
	// 2. now plot correctnessfactor
	for i,runwithresponses := range Runs {
		// values for r2 to reset each run

	// get response value and check if it's a float64 type
	expectedconc, err := runwithresponses.GetResponseValue("Absorbance ExpectedConc "+strconv.Itoa(Wavelength))
	
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	expectedconcfloat,floattrue := expectedconc.(float64)
	// if float64 is true 
	if floattrue {
		xvalues = append(xvalues, expectedconcfloat)
	}else {
		Errorf("Run"+fmt.Sprint(i,runwithresponses)+" ExpectedConc:"+fmt.Sprint(expectedconcfloat))
	}

	// get response value and check if it's a float64 type
	correctness, err := runwithresponses.GetResponseValue("Absorbance CorrectnessFactor "+strconv.Itoa(Wavelength))
	
	if err != nil{
		fmt.Println(err.Error())
		Errors = append(Errors,err.Error())
	}
	
	correctnessfloat,floattrue := correctness.(float64)
	
	if floattrue {
		yvalues = append(yvalues,correctnessfloat )
	}else {
		fmt.Println(err.Error())
		Errorf(" Absorbance CorrectnessFactor:"+fmt.Sprint(correctnessfloat))
	}
		
	}
		
		
	R2_CorrectnessFactor,_,_ = plot.Rsquared("Expected Conc", xvalues, "Correctness Factor", yvalues)
	//run.AddResponseValue("R2", rsquared)

	correctnessgraph,err := plot.Plot(xvalues, [][]float64{yvalues})
	
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	plot.AddAxesTitles(correctnessgraph, "Target Conc M/l", "Correctness Factor (Measured Conc / Expected Conc)")
			
	correctnessgraph.Title.Text = Molecule.CName + ": Correctness Factor vs Target Concentration"
	
	
	
	CorrectnessFactorPlot, err = plot.Export(correctnessgraph, "20cm","20cm",filenameandextension[0]+"_correctnessfactor"+".png")
	
	if err != nil{
		Errors = append(Errors,err.Error())
		Errorf(err.Error())

	}
	
	// reset
		xvalues = make([]float64, 0)
		yvalues = make([]float64, 0)

		// add origin
		xvalues = append(xvalues, 0.0)
		yvalues = append(yvalues, 0.0)
	
	// 3. now look for systematic errors
	for i,runwithresponses := range Runs {
		// values for r2 to reset each run

	// get response value and check if it's a float64 type
	runorder, err := runwithresponses.GetResponseValue("Runorder")
	
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	runorderint,inttrue := runorder.(int)
	// if int is true 
	if inttrue {
		xvalues = append(xvalues, float64(runorderint))
	}else {
		Errorf("Run"+fmt.Sprint(i,runwithresponses)+" Run Order:"+fmt.Sprint(runorderint), " not an int")
	}

	
	// get response value and check if it's a float64 type
	actualconc, err := runwithresponses.GetResponseValue("AbsorbanceActualConc")
	
	if err != nil{
		fmt.Println(err.Error())
		Errors = append(Errors,err.Error())
	}
	
	actualconcfloat,floattrue := actualconc.(float64)
	
	if floattrue {
		yvalues = append(yvalues,actualconcfloat )
	}else {
		fmt.Println(err.Error())
		Errorf(" ActualConc:"+fmt.Sprint(actualconcfloat))
	}
	}

	runorderconcgraph,err := plot.Plot(xvalues, [][]float64{yvalues})
	
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	plot.Export(runorderconcgraph,"10cm","10cm", filenameandextension[0]+"_runorder"+".png")
	
	// reset
		xvalues = make([]float64, 0)
		yvalues = make([]float64, 0)

		// add origin
		xvalues = append(xvalues, 0.0)
		yvalues = append(yvalues, 0.0)
		
	// 4.  now look for systematic errors with correctness factor
	for i,runwithresponses := range Runs {
		// values for r2 to reset each run

	// get response value and check if it's a float64 type
	runorder, err := runwithresponses.GetResponseValue("Runorder")
	
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	runorderint,inttrue := runorder.(int)
	// if int is true 
	if inttrue {
		xvalues = append(xvalues, float64(runorderint))
	}else {
		Errorf("Run"+fmt.Sprint(i,runwithresponses)+" Run Order:"+fmt.Sprint(runorderint), " not an int")
	}

	// get response value and check if it's a float64 type
	correctness, err := runwithresponses.GetResponseValue("Absorbance CorrectnessFactor "+strconv.Itoa(Wavelength))
	
	if err != nil{
		fmt.Println(err.Error())
		Errors = append(Errors,err.Error())
	}
	
	correctnessfloat,floattrue := correctness.(float64)
	
	if floattrue {
		yvalues = append(yvalues,correctnessfloat )
	}else {
		fmt.Println(err.Error())
		Errorf(" Absorbance CorrectnessFactor:"+fmt.Sprint(correctnessfloat))
	}
		
	}
		
	runordercorrectnessgraph,err := plot.Plot(xvalues, [][]float64{yvalues})
	
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	plot.Export(runordercorrectnessgraph,"10cm","10cm", filenameandextension[0]+"_runorder_correctnessfactor"+".png")
	
	// 5. workout CV for each volume
	replicateactualconcmap := make(map[string][]float64)
	VolumeToActualConc = make(map[string]Dataset) 
	replicatevalues := make([]float64,0)
	
	replicatecorrectnessmap := make(map[string][]float64)
	correctnessvalues := make([]float64,0)
	VolumeToCorrectnessFactor = make(map[string]Dataset) 
	
	//counter := 0
	
	// make map of replicate values for Actual Conc
	for _,runwithresponses := range Runs {
	
	volstr, err := runwithresponses.GetAdditionalInfo("Volume")

	if err != nil {
		Errorf(err.Error())
	}
	
	/*
	repstr, err := runwithresponses.GetAdditionalInfo("Replicate")
	
	if err != nil {
		Errorf(err.Error())
	}
	*/
	actualconc, err := runwithresponses.GetResponseValue("AbsorbanceActualConc")
	
	if err != nil {
		Errorf(err.Error())
	}
	
	/*rep, err := strconv.Atoi(repstr.(string))
	
	if err != nil {
		Errorf(err.Error())
	}
	*/
	
	// Actual Conc map
	if _,found := replicateactualconcmap[volstr.(string)];found /*&& rep == counter*/{
		replicatevalues =replicateactualconcmap[volstr.(string)] 
		replicatevalues = append(replicatevalues,actualconc.(float64))
		replicateactualconcmap[volstr.(string)]= replicatevalues 
		replicatevalues = make([]float64,0)
		//counter++
	} else if _,found := replicateactualconcmap[volstr.(string)];!found{
		replicatevalues =append(replicatevalues,actualconc.(float64))
		replicateactualconcmap[volstr.(string)]=replicatevalues 
		replicatevalues = make([]float64,0)
		//counter++
	} 
	
	
	// get response value and check if it's a float64 type
	correctness, err := runwithresponses.GetResponseValue("Absorbance CorrectnessFactor "+strconv.Itoa(Wavelength))
	
	if err != nil{
		fmt.Println(err.Error())
		Errors = append(Errors,err.Error())
	}
	
	correctnessfloat,floattrue := correctness.(float64)
	
	if !floattrue {
		fmt.Println(err.Error())
		Errorf(" Correctnessfloat not float but:"+fmt.Sprint(correctnessfloat))
	}
	
	// correctness factor map
	if _,found := replicatecorrectnessmap[volstr.(string)];found /*&& rep == counter*/{
		correctnessvalues =replicatecorrectnessmap[volstr.(string)] 
		correctnessvalues = append(correctnessvalues,correctnessfloat)
		replicatecorrectnessmap[volstr.(string)]= correctnessvalues 
		correctnessvalues = make([]float64,0)
		//counter++
	} else if _,found := replicatecorrectnessmap[volstr.(string)];!found{
		correctnessvalues =append(correctnessvalues,correctnessfloat)
		replicatecorrectnessmap[volstr.(string)]=correctnessvalues 
		correctnessvalues = make([]float64,0)
		//counter++
	} 
	
	
	
	
	
	}
	
	// process into datasets
	for key,values := range replicateactualconcmap {
	
	
	var dataset Dataset
		// process replicates into mean and cv
	dataset.Name = key + "_AbsorbanceActualConc"
	dataset.Mean,_ = stats.Mean(values)
	dataset.StdDev,_ = stats.StdDevS(values)
	dataset.Values = values

	dataset.CV = dataset.StdDev / dataset.Mean * float64(100)
	VolumeToActualConc[key] = dataset
	
	
	}

	// process into datasets
	for key,values := range replicatecorrectnessmap {
	
	
	var dataset Dataset
		// process replicates into mean and cv
	dataset.Name = key + "_CorrectnessFactor"
	dataset.Mean,_ = stats.Mean(values)
	dataset.StdDev,_ = stats.StdDevS(values)
	dataset.Values = values

	dataset.CV = dataset.StdDev / dataset.Mean * float64(100)
	
	// if CV == Infinity or Not a number set to -1.0
	if math.IsInf(dataset.CV,0)|| math.IsNaN(dataset.CV){
		dataset.CV = -1.0
	}
	
	VolumeToCorrectnessFactor[key] = dataset
	
	
	}


if ManualComparison {
	
	// reset
		xvalues = make([]float64, 0)
		yvalues = make([]float64, 0)

		// add origin
		xvalues = append(xvalues, 0.0)
		yvalues = append(yvalues, 0.0)
	
	
	// 2. now plot correctnessfactor
	for i,runwithresponses := range Runs {
		// values for r2 to reset each run

	// get response value and check if it's a float64 type
	expectedconc, err := runwithresponses.GetResponseValue("Absorbance ExpectedConc "+strconv.Itoa(Wavelength))
	
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	expectedconcfloat,floattrue := expectedconc.(float64)
	// if float64 is true 
	if floattrue {
		xvalues = append(xvalues, expectedconcfloat)
	}else {
		Errorf("Run"+fmt.Sprint(i,runwithresponses)+" ExpectedConc:"+fmt.Sprint(expectedconcfloat))
	}

	// get response value and check if it's a float64 type
	correctness, err := runwithresponses.GetResponseValue("Absorbance ManualCorrectnessFactor "+strconv.Itoa(Wavelength))
	
	if err != nil{
		fmt.Println(err.Error())
		Errors = append(Errors,err.Error())
	}
	
	correctnessfloat,floattrue := correctness.(float64)
	
	if floattrue {
		yvalues = append(yvalues,correctnessfloat )
	}else {
		fmt.Println(err.Error())
		Errorf("Manual Absorbance CorrectnessFactor:"+fmt.Sprint(correctnessfloat))
	}
		
	}
		
		
	R2_CorrectnessFactor,_,_ = plot.Rsquared("Expected Conc", xvalues, "Manual Correctness Factor", yvalues)
	//run.AddResponseValue("R2", rsquared)

	correctnessgraph, err := plot.Plot(xvalues, [][]float64{yvalues})
	
	if err != nil{
		Errors = append(Errors,err.Error())
	}
	
	plot.Export(correctnessgraph,"10cm","10cm", filenameandextension[0]+"_Manualcorrectnessfactor"+".png")
	
	
	
}

	
}


// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
	
	CVpass = true
	
	if R2 > R2threshold {
		R2Pass = true
	} else {
		Errors = append(Errors, fmt.Sprint("R2 threshold of ", R2threshold ," not met; R2 value = ",R2))
	}
	
	for key,dataset := range VolumeToActualConc {
	
	if dataset.CV > CVthreshold {
		CVpass = false
		Errors = append(Errors, fmt.Sprint(key," coefficient of variance above ", CVthreshold ," percent threshold; CV value = ",dataset.CV))
	}
	}
	
}

type Dataset struct {
	Name string
	Values []float64
	Mean float64
	StdDev float64
	CV float64
}
