// Protocol WavelengthParser performs something.
protocol WavelengthParser

// Place golang packages to import here
import (
	"fmt"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/export"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/platereader/dataset"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/platereader/dataset/parse"
	"github.com/antha-lang/antha/antha/anthalib/wtype"
)

// Parameters to this protocol
Parameters (
	MarsResultsFileXLSX File
	OutputFileName string
	Wavelength int
	SheetNumber int
	BlankCorrect bool
	BlankWells []string
	UseScript int //optional
	PlateReaderFileType string
	ReadingTypeinMarsFile string
)

// Output data of this protocol
Data (
	RawData map[string]float64
	BlankedData map[string]float64
	OutPutFile File
	Warnings []Warning
)

// Physical inputs to this protocol
Inputs (
	InputPlateLayout *LHPlate
)

// Physical outputs to this protocol
Outputs ()

// Conditions to run on startup
Setup {

}

// The core process for this protocol. These steps are executed for each input.
Steps {

	var err error
	var warnings []error

	if Wavelength == 0 {
		Wavelength = 600
	}

	if OutputFileName == "" {
		OutputFileName = "Output.xlsx"
	}

	data, err := MarsResultsFileXLSX.ReadAll()

	if err != nil {
		Errorf("Error in reading MARS file %s: %s", MarsResultsFileXLSX.Name, err.Error())
	}

	var plateReaderData dataset.AbsorbanceData

	if PlateReaderFileType == "" {
		PlateReaderFileType = "Mars"
	}

	if PlateReaderFileType == "Mars" {
		plateReaderData, err = parse.ParseMarsXLSXBinary(data, SheetNumber)
		if err != nil {
			Warnings = append(Warnings, wtype.NewWarning(err.Error()))
			Errorf(err.Error())
		}
	} else if PlateReaderFileType == "SpectraMax" {
		plateReaderData, err = parse.ParseSpectraMaxData(data)
		if err != nil {
			Warnings = append(Warnings, wtype.NewWarning(err.Error()))
			Errorf(err.Error())
		}
	}

	//if len input plate zero

	//if err != nil {
	//Errorf("Error in reading InputPlateLayout file %s: %s", InputPlateLayout.Name, err.Error())
	//}

	componentsMap := make(map[string]*LHComponent)

	for _, well := range InputPlateLayout.AllWellPositions(wtype.BYCOLUMN) {
		if !InputPlateLayout.WellMap()[well].Empty() {
			component := InputPlateLayout.WellMap()[well].WContents //is empty for error
			componentsMap[well] = component
		}
	}

	blankValues := make([]float64, 0)
	var blankValue float64

	if len(BlankWells) == 0 && BlankCorrect {
		Errorf("Cannot Blank correct if no blank well is specified")
	}

	if len(BlankWells) > 0 && BlankCorrect {
		for i := range BlankWells {
			blankValue, err = plateReaderData.AbsorbanceReading(BlankWells[i], Wavelength, ReadingTypeinMarsFile)
			if err != nil {
				Errorf(fmt.Sprint("Blank sample not found at position ", BlankWells[i], ": ", err.Error()))
			}
		}
		blankValues = append(blankValues, blankValue)
	}

	for well, _ := range componentsMap {

		if len(BlankWells) > 0 && BlankCorrect {
			blankCorrected, err := plateReaderData.BlankCorrect([]string{well}, BlankWells, Wavelength, ReadingTypeinMarsFile)
			if err != nil {
				warnings = append(warnings, err)
				Errorf(err.Error())
			}
			BlankedData[well] = blankCorrected
		}
		rawData, err := plateReaderData.AbsorbanceReading(well, Wavelength, ReadingTypeinMarsFile)
		if err != nil {
			warnings = append(warnings, err)
			Errorf(err.Error())
		}
		RawData[well] = rawData
	}
	var csv [][]string
	var headers []string = []string{"Well", "SampleName", "BlankedReading"}
	csv = append(csv, headers)
	for well, data := range BlankedData {
		var data []string = []string{well, componentsMap[well].CName, fmt.Sprint(data)}
		csv = append(csv, data)
	}
	OutPutFile, err = export.CSV(csv, OutputFileName)
	if err != nil {
		warnings = append(warnings, err)
		Errorf(err.Error())
	}
}

// Run after controls and a steps block are completed to post process any data
// and provide downstream results
Analysis {

}

// A block of tests to perform to validate that the sample was processed
// correctly. Optionally, destructive tests can be performed to validate
// results on a dipstick basis
Validation {

}
