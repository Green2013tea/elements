// Protocol WavelengthParser performs something.
protocol WavelengthParser

// Place golang packages to import here
import (
	"fmt"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/doe"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/platereader/dataset"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/platereader/dataset/parse"
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"time"
)

// Parameters to this protocol
Parameters (
	MarsResultsFileXLSX File
	InputPlateLayout File
	OutputFileName string
	Wavelength int
	SheetNumber int
	BlankCorrect bool
	BlankWell string
	UseScript int //optional
)

// Output data of this protocol
Data (
	RawData []TimecourseData
	BlankedData []TimecourseData
	OutPutFile File
	Warnings []error
)

// Physical inputs to this protocol
Inputs (
)

// Physical outputs to this protocol
Outputs (
)

// Conditions to run on startup
Setup {

}

// The core process for this protocol. These steps are executed for each input.
Steps {

	var err error
	var warnings []error

	if Wavelength == 0 {
		Wavelength = 600
	}

	if OutputFileName == "" {
		OutputFileName = "Output.xlsx"
	}

	data, err := MarsResultsFileXLSX.ReadAll()

	if err != nil {
		Errorf("Error in reading MARS file %s: %s", MarsResultsFileXLSX.Name, err.Error())
	}

	var plateReaderData dataset.AbsorbanceData

	if PlateReaderFileType == "" {
		PlateReaderFileType = "Mars"
	}

	plateReaderData, err = parse.ParseMarsXLSXBinary(data, SheetNumber)

	if err != nil {
		warnings = append(warnings, err)
		Errorf(err.Error())
	}

	//ParsePlate
	result := RunSteps (ParsePlate, Parameters {
		InputCSVfile: InputPlateLayout
	}
	)

	inputPlateFile := result.Outputs.PlatewithComponents
	err = result.Outputs.Error

	if err != nil {
		Errorf("Error in reading InputPlateLayout file %s: %s", InputPlateLayout.Name, err.Error())
	}

	var componentsMap = make(map[string]*LHComponent)

	for _, inputPlateContents := range inputPlateFile.AllWellPositions(wtype.BYCOLUMN) {
				component := inputPlateFile.WellMap()[inputPlateContents]
				componentsMap = append(componentsMap, component)
	}

	readingValues := make([]wavelengthReading, 0)
	var yBlank []wavelengthReading
	var reading wavelengthReading


	if len(BlankWell) == 0 && BlankCorrect {
		Errorf("Cannot Blank correct if no blank well is specified")
	}

	if len(BlankWell) > 0 && BlankCorrect {
		_, yBlank, err = plateReaderData.TimeCourse(BlankWell, Wavelength, Wavelength, UseScript)

		if err != nil {
			warnings = append(warnings, err)
			Errorf(err.Error())
		}
	}


	//Blank correct function on interac AbsorbanceData

	//blankCorrectInterface := plateReaderData.BlankCorrect()


	for k, run := range runs {

		var rawData TimecourseData
		var blankCorrectedData TimecourseData

		well, err := runs[k].GetAdditionalInfo("Location")
		if err != nil {
			warnings = append(warnings, err)
			Errorf(err.Error())
		}

		_, y, err := plateReaderData.TimeCourse(well.(string), Wavelength, Wavelength, UseScript)
		if err != nil {
			warnings = append(warnings, err)
			Errorf(err.Error())
		}

		rawData.OD = copySlice(y)

			for i := range y {

				if y[i] > 1.0 {
					var readingError readingOutOfRange
					readingError.Well = well.(string)
					readingError.Reading = y[i]
					readingError.ErrorMessage = fmt.Sprintf("Reading %f out of range (> 1.0) for Well %s", readingError.Reading, readingError.Well)
					break
				}
			//}

		//	for i := range y {
				if BlankCorrect {
					if y[i] - yBlank[i] < 0 {

						var blankError readingOutOfRange
						blankError.Well = well.(string)
						blankError.Reading = y[i] - yBlank[i]
						blankError.ErrorMessage = fmt.Sprintf("Blank corrected reading %f out of range (< 1.0) got Well %s", blankError.Reading, blankError.Well)
					}
					reading = y[i] - yBlank[i]
				} else {
					reading = y[i]
				}

				readingValues = append(readingValues, reading)
			}


			maxReading, _ := Max(y)

			run = doe.AddNewResponseFieldandValue(run, "Maximum Wavelength Reading", maxReading)
			run = doe.AddNewResponseFieldandValue(run, "Runorder", k)

			RawData = append(RawData, rawData)
			BlankedData = append(BlankedData, blankCorrectedData)


	}


}

func Max(data []float64) (max float64, index int) {

	for i, value := range data {
		if i == 0 {
			max = value
			index = i
		} else if value > max {
			max = value
			index = i
		}
	}
	return
}

func copySlice (f []float64) []float64 {
		var nf []float64
		for j := range f {
			nf = append(nf, f[j])
		}
		return nf
}

type wavelengthReading struct {
	Well		string
	Blank		float64
	Reading	float64
}

type readingOutOfRange struct {
	Well           string
	TimeinNanoSecs time.Duration
	Reading        float64
	ErrorMessage   string
	Error					 error
}

type TimecourseData struct {
	TimeinNanoSecs       []time.Duration //wunit.Time
	OD                   []float64
	Fluorophore          []float64
	dFluorophoreperS     []float64
	MaxFluorophore       float64
	AverageFluorophore   float64
	TMaxFluorophore      float64
	TMaxdFluorophoreperS float64
}

// Run after controls and a steps block are completed to post process any data
// and provide downstream results
Analysis {

}

// A block of tests to perform to validate that the sample was processed
// correctly. Optionally, destructive tests can be performed to validate
// results on a dipstick basis
Validation {

}
