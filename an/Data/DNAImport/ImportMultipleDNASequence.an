// Protocol for creating a DNASequence from a sequence file format. // Supported format: .fasta
protocol ImportMultipleDNASequence

import (
	"fmt"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/sequences"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/sequences/parse"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/text"
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"path/filepath"
)

// Input parameters for this protocol
Parameters (
	SequenceFile File                      //Only supported file format: .fasta
	OverrideSequenceType map[string]string //Optional for the user to override specification of SequenceType using the name of the sequence specified in the file as the key. Each sequence name should be assigned to a SequenceType of the following list: Plasmid, Linear, SingleStranded. If no entry for a sequence is specified the value in the sequence file is used. Alternatively a "default" value can be specified which will apply to all sequences with no entry.
	CheckForORFs bool                      //If true, sequence is searched for ORF's
)

// Data which is returned from this protocol
Data (
	DNA []DNASequence //Return DNA sequence as type DNASequence
	Status string     //Status for user
	Warnings error    //Warnings for user
)

// Physical inputs to this protocol
Inputs ()

// Physical outputs from this protocol
Outputs ()

Requirements {

}

// Actions to perform before protocol itself
Setup {
}

// Core process of the protocol: steps to be performed for each input
Steps {
	//Use function DNAFileToDNASequence to read in file. The function determines
	//which file type was given as input and returns the DNA sequence as type DNASequence

	if filepath.Ext(SequenceFile.Name) != ".fasta" {
		Errorf("The file format of %s is not supported. Please use file of format .fasta for this element.", SequenceFile.Name)
	}

	seqs, err := parse.DNAFileToDNASequence(SequenceFile)

	if err != nil {
		Errorf("The file %s could not be imported. Error: %s ", SequenceFile.Name, err.Error())
	}

	if err == nil {
		DNA = seqs
		l := len(DNA) - 1

		if CheckForORFs {
			for i := 0; i <= l; i++ {
				//Finds all ORFs in imported DNA sequence
				orfs := sequences.FindallORFs(DNA[i].Seq)
				if len(DNA[i].Features) == 0 {
					features := sequences.ORFs2Features(orfs)
					DNA[i] = wtype.Annotate(DNA[i], features)
				}
			}
		}

		if len(OverrideSequenceType) > 0 {

			for i := 0; i <= l; i++ {
				name := DNA[i].Nm
				if seqType, found := OverrideSequenceType[name]; found {
					if seqType == "Plasmid" {
						DNA[i].Plasmid = true
						DNA[i].Singlestranded = false
					} else if seqType == "Linear" {
						DNA[i].Plasmid = false
						DNA[i].Singlestranded = false
					} else if seqType == "SingleStranded" {
						DNA[i].Plasmid = false
						DNA[i].Singlestranded = true
					} else {
						Errorf("SequenceType %s is unknown for %s. Please specify as Plasmid, Linear or SingleStranded", seqType, name)
					}
				} else if !found {
					if seqType, found := OverrideSequenceType["default"]; found {
						if seqType == "Plasmid" {
							DNA[i].Plasmid = true
							DNA[i].Singlestranded = false
						} else if seqType == "Linear" {
							DNA[i].Plasmid = false
							DNA[i].Singlestranded = false
						} else if seqType == "SingleStranded" {
							DNA[i].Plasmid = false
							DNA[i].Singlestranded = true
						} else {
							err = fmt.Errorf("SequenceType %s is unknown. Please specify type as Plasmid, Linear or SingleStranded.", seqType)
						}
					} else {
						fmt.Printf("For %s no SequenceType was found in OverrideSequenceType. No default value was declared so %s's sequenceType was assigned from file. Please check if %s is spelled correctly in map, if SequenceType should be reassigned. ", name, name, name)
					}

				}
			}
		}

		Status = fmt.Sprintln(
			text.Print("DNA_Seq: ", DNA),
		)

		Warnings = err

	}
}

// Actions to perform after steps block to analyze data
Analysis {

}

Validation {

}
