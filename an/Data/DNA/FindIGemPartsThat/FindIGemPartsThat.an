// example protocol which allows a primitive method for searching the igem registry
// for parts with specified functions or a specified status (e.g. A = available or "Works", or results != none)
// see the igem package ("github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/igem")
// and igem website for more details about how to make the most of this http://parts.igem.org/Registry_API
protocol FindIGemPartsThat

import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"fmt"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/igem"
	"strings"
	"strconv"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/text"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/search"
)

// Input parameters for this protocol (data)
Parameters (
    //    IGem Part Name classifications. Valid options are :	
    //    "GENERIC":          "BBa_B"	Generic basic parts such as Terminators, DNA, and Ribosome Binding Site
    //    "PROTEINCODING":    "BBa_C"	Protein coding parts
    //    "REPORTER":         "BBa_E"	Reporter parts
    //    "SIGNALLING":       "BBa_F"	Signalling parts
    //    "PRIMER":           "BBa_G"	Primer parts
    //    "IAPPROJECT":       "BBa_I"	IAP 2003, 2004 project parts
    //    "IGEMPROJECT":      "BBa_J"	iGEM project parts
    //    "TAG":              "BBa_M"	Tag parts
    //    "PROTEINGENERATOR": "BBa_P"	Protein Generator parts
    //    "INVERTER":         "BBa_Q"	Inverter parts
    //    "REGULATORY":       "BBa_R"	Regulatory parts
    //    "INTERMEDIATE":     "BBa_S"	Intermediate parts
    //    "CELLSTRAIN":       "BBa_V"	Cell strain parts
	Parttype			string
	
	// e.g. strong, arsenic, fluorescent, alkane, logic gate
	Partdescriptions	[]string  
	
	// This should be set to true
	ExactTypeOnly bool
	
	MatchAllDescriptions bool
	
	// only return parts marked as available in registry
	OnlyreturnAvailableParts bool
	
	// only return parts marked as working in registry
	OnlyreturnWorkingparts bool
)

// Physical Inputs to this protocol with types
Inputs (

)

// Physical outputs from this protocol with types
Outputs (
	
)

// Data which is returned from this protocol, and data types
Data (
	Warnings error
	Partslist []string
	PartMap map[string][]string // i.e. map[description]list of parts matching description
	BiobrickDescriptions map[string]string // i.e. map[biobrickID]description
	HighestRatedMatch string
	HighestRatedMatchScore int
	HighestRatedMatchDNASequence wtype.DNASequence
)
// Input Requirement specification
Requirements {
	
}

// Conditions to run on startup
Setup {}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {

	Parttypes := []string{Parttype}

	var BackupParts []string 
	var WorkingBackupParts []string
	
	// initialise some variables for use later
	var parts [][]string
	OriginalPartMap := make(map[string][]string)
	PartMap = make(map[string][]string)
	BiobrickDescriptions = make(map[string]string)
	var highestrating int
	var parttypemap map[string]string
	partstatus := ""
	
	if OnlyreturnAvailableParts {
		partstatus = "A"
	} 
	
	// first we'll parse the igem registry based on the short description contained in the fasta header for each part sequence
	for _, parttype := range Parttypes {
		
		var subparts []string
		var err error
		
		subparts, parttypemap, err = igem.FilterRegistry(parttype,[]string{partstatus},ExactTypeOnly)
		
		if err != nil {
			Errorf("Error filtering igem registry: %s", err.Error())
		}
		
		parts = append(parts,subparts)
		OriginalPartMap[parttype+"_"+partstatus]=subparts
		PartMap[parttype+"_"+partstatus]=subparts
	}
	 
	
	othercriteria := ""
	if OnlyreturnWorkingparts {
		othercriteria = "WORKS"
		}
	
	
	for desc,subparts := range OriginalPartMap {
	
	partdetails := igem.LookUp(subparts)

	// now we can get detailed information of all of those records to interrogate further
	// this can be slow if there are many parts to check 
	// Parts will be added if they contain either description not both
	for i := range Partdescriptions {
	
	for _, subpart := range subparts {
		
		// check if key words are in description and that status == "WORKS" if only working parts are desired
		 if !MatchAllDescriptions && strings.Contains(strings.ToUpper(partdetails.Description(subpart)),strings.ToUpper(Partdescriptions[i])) &&
			strings.Contains(strings.ToUpper(partdetails.Results(subpart)), strings.ToUpper(othercriteria)) {
				
			if !search.InSlice(subpart,BackupParts){
			BackupParts = append(BackupParts, subpart)
			}
			// ensure the highest rated part is returned
			rating, err := strconv.Atoi(partdetails.Rating(subpart))
			
			if err == nil && rating >highestrating{
			HighestRatedMatch = subpart
			
			seq := partdetails.Sequence(HighestRatedMatch)
			
			HighestRatedMatchDNASequence = wtype.MakeLinearDNASequence(HighestRatedMatch,seq)
			highestrating = rating
			}
		}else if MatchAllDescriptions && search.Containsallthings((partdetails.Description(subpart)),Partdescriptions) &&
			strings.Contains(partdetails.Results(subpart), othercriteria) {
				
			if !search.InSlice(subpart,BackupParts){
			BackupParts = append(BackupParts, subpart)
			}
			// ensure the highest rated part is returned
			rating, err := strconv.Atoi(partdetails.Rating(subpart))
			
			if err == nil && rating >highestrating{
			HighestRatedMatch = subpart
			
			seq := partdetails.Sequence(HighestRatedMatch)
			
			HighestRatedMatchDNASequence = wtype.MakeLinearDNASequence(HighestRatedMatch,seq)
			highestrating = rating
			}
		}
		if !MatchAllDescriptions  && strings.Contains(strings.ToUpper(partdetails.Description(subpart)),strings.ToUpper(Partdescriptions[i])) &&
			strings.Contains(partdetails.Results(subpart), "WORKS"){
				if !search.InSlice(subpart,WorkingBackupParts){
			WorkingBackupParts = append(WorkingBackupParts,subpart)
			}
		} else if MatchAllDescriptions && search.Containsallthings((partdetails.Description(subpart)),Partdescriptions) &&
			strings.Contains(partdetails.Results(subpart), "WORKS") {
				if !search.InSlice(subpart,WorkingBackupParts){
			WorkingBackupParts = append(WorkingBackupParts,subpart)
			}
		}		
		// add to look up table to report back to user
		if MatchAllDescriptions {
			var partdesc string
			
			for _, descriptor := range Partdescriptions {
				partdesc = partdesc + "_"+descriptor
			}
		PartMap[desc+"_"+partdesc]=BackupParts
		PartMap[desc+"_"+partdesc+"+WORKS"]=WorkingBackupParts
			
		}else if !MatchAllDescriptions {
		
		PartMap[desc+"_"+Partdescriptions[i]]=BackupParts
		PartMap[desc+"_"+Partdescriptions[i]+"+WORKS"]=WorkingBackupParts
		}
		
		
	}
		for _,part := range WorkingBackupParts {
			Partslist = append(Partslist,part)
		}
		
		// remove duplicates
		Partslist = search.RemoveDuplicates(Partslist)
		
		// reset
		//FulllistBackupParts = BackupParts 
		BackupParts = make([]string,0)
		WorkingBackupParts = make([]string,0)
	
	//i = i + 1
	if MatchAllDescriptions {
		// don't need to loop through each description if we're matching all
		continue
	}
	}
	for _, subpartarray := range PartMap {
		for _,subpart := range subpartarray {
				if partdetails.Description(subpart) != ""{
					BiobrickDescriptions[subpart]= partdetails.Description(subpart)
				}else {
					BiobrickDescriptions[subpart] = parttypemap[subpart]
					}
			}
		}
	}
	
	HighestRatedMatchScore = highestrating


	// print in pretty format on terminal 
	for key, value := range PartMap {
		fmt.Println(text.Print(key,value))
	}

}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
}
