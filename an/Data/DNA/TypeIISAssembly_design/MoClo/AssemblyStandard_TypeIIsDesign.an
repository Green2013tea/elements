// This protocol is intended to design assembly parts using a specified enzyme. 
// overhangs are added to complement the adjacent parts and leave no scar. 
// parts can be entered as genbank (.gb) files, sequences or biobrick IDs
// If assembly simulation fails after overhangs are added. In order to help the user
// diagnose the reason, a report of the part overhangs 
// is returned to the user along with a list of cut sites in each part.
protocol AssemblyStandard_TypeIIsDesign

import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"fmt"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/enzymes"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/export"

	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/sequences"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/enzymes/lookup"

	"strconv"
	"strings"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/text"
	"path/filepath"
)

// Input parameters for this protocol (data)
Parameters (
	Constructname 					string
	Seqsinorder						[]DNASequence
	AssemblyStandard				string //MoClo
	Level							string // of assembly standard
	Vector							DNASequence
	PartMoClotypesinorder			[]string // labels e.g. pro = promoter
	OtherEnzymeSitesToRemove		[]string
	ORFstoConfirm					[]string // enter each as amino acid sequence
	RemoveproblemRestrictionSites 	bool
	OnlyRemovesitesinORFs			bool
	EndsAlreadyadded 				bool
	ExporttoFastaFile 				bool
	BlastSeqswithNoName				bool
	
	// Option to add Level 1 adaptor sites to the Promoters and terminators to support hierarchical assembly
	// If Custom design the valid options currently supported are: "Device1","Device2", "Device3". 
	// If left empty no adaptor sequence is added.
	MakeLevel1Device 		string
	ReverseLevel1Orientation bool 
)

// Physical Inputs to this protocol with types
Inputs (

)

// Physical outputs from this protocol with types
Outputs (
	
)

// Data which is returned from this protocol, and data types
Data (
	Warnings error
	Status string
	Simulationpass bool
	OriginalParts []DNASequence 
	PartsWithSitesRemoved []DNASequence // and level 1 ends added if MakeLevel1Device is selected
	PartswithOverhangs []DNASequence // parts to order
	PartsAndVector []DNASequence // parts to order + vector
	NewDNASequence DNASequence // desired sequence to end up with after assembly
	Insert DNASequence // sequence of the assembled insert. Useful for sequencing validation and Primer design
	ORFmissing bool
	Endreport string
	PositionReport []string
	AssembledSequenceFile File
	PartsToOrderFile File
	
)
// Input Requirement specification
Requirements {
	// e.g. are MoClo types valid?
}

// Conditions to run on startup
Setup {}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	
	// set warnings reported back to user to none initially
	warnings := make([]string, 0)

	// declare some temporary variables to be used later
	var warning string
	var err error
	
	// get these directly from Parameters
	var partsinorder = Seqsinorder
	var vectordata  = Vector

	Status = "all parts available"
	
	// export this as data output
	OriginalParts = partsinorder
	// check parts for restriction sites first and remove if the user has chosen to
	enz, found := enzymes.Enzymelookup[AssemblyStandard][Level]
	
	if !found {
		Errorf("AssemblyStandard ",AssemblyStandard," level ",Level, " not found")
	}

	// get properties of other enzyme sites to remove
	removetheseenzymes := make([]wtype.RestrictionEnzyme,0)
	removetheseenzymes = append(removetheseenzymes,enz.RestrictionEnzyme)
	
	for _,enzyme := range OtherEnzymeSitesToRemove {
		
		enzyTypeII, err := lookup.EnzymeLookup(enzyme)
		
		if err!= nil {
			Errorf(err.Error())
		}
		
		removetheseenzymes = append(removetheseenzymes,enzyTypeII)
	}
	
	// check number of sites per part and return if > 0!
	var report []string
	var siteFound bool
	for _, part := range partsinorder {

		info := enzymes.Restrictionsitefinder(part, removetheseenzymes)

		for i := range info {
		sitepositions := enzymes.SitepositionString(info[i])

		if len(sitepositions)>0{
			siteFound = true
		}
		sitepositions = fmt.Sprint(part.Nm+" "+info[i].Enzyme.Name+" positions:", sitepositions)
		report = append(report, sitepositions)
		}
	}
	if siteFound {
		
		errormessage := fmt.Sprintf("Found problem restriction sites in 1 or more parts: %s", report)
		
		if !RemoveproblemRestrictionSites && !EndsAlreadyadded {
			Errorf(errormessage)
		}else{
			warnings = append(warnings, errormessage)
		}
	}	
	
	
	warning = text.Print("RemoveproblemRestrictionSites =", RemoveproblemRestrictionSites)
	warnings = append(warnings, warning)
	if RemoveproblemRestrictionSites && !EndsAlreadyadded{
		newparts := make([]DNASequence, 0)
		warning = "Starting process or removing restrictionsite"
		warnings = append(warnings, warning)

		for _, part := range partsinorder {
			if part.Seq != ""{
				info := enzymes.Restrictionsitefinder(part, removetheseenzymes)
	
				for _, anysites := range info {
					if anysites.Sitefound {
						warning = "problem " + anysites.Enzyme.Name+" site found in " + part.Nm
						warnings = append(warnings, warning)
						orf, orftrue := sequences.FindBiggestORF(part.Seq)
						warning = fmt.Sprintln(anysites.Enzyme.Name+" site found in orf ", part.Nm, " ", orftrue, " site positions ", anysites.Positions("ALL"), "orf between", orf.StartPosition, " and ", orf.EndPosition, /*orf.DNASeq[orf.StartPosition:orf.EndPosition]*/)
						warnings = append(warnings, warning)
						if orftrue && len(orf.ProtSeq) > 20 {
							allsitestoavoid := make([]string, 0)
							allsitestoavoid = append(allsitestoavoid, anysites.Recognitionsequence, sequences.RevComp(anysites.Recognitionsequence))
							orfcoordinates := sequences.MakeStartendPair(orf.StartPosition, orf.EndPosition)
							for _, position := range anysites.Positions("ALL") {
								if orf.StartPosition < position && position < orf.EndPosition {
									originalcodon := ""
									codonoption := ""
									originalPart := part.Dup()
									part, originalcodon, codonoption, err = sequences.ReplaceCodoninORF(originalPart, orfcoordinates, position, allsitestoavoid)
									warning = fmt.Sprintln("sites to avoid: ", allsitestoavoid[0], allsitestoavoid[1])
									warnings = append(warnings, warning)
									warnings = append(warnings, "For Part Sequence: "+originalPart.Seq+" position: "+strconv.Itoa(position)+" original codon to replace: "+originalcodon+" replaced with replacementcodon: "+codonoption)
									if err != nil {
										warning := fmt.Sprint("removal of "+anysites.Enzyme.Name+" site from orf "+orf.DNASeq, "in part "+part.Nm + " failed! improve your algorithm! "+err.Error())
										warnings = append(warnings, warning)
										Errorf(warning)
									}
								} else if !OnlyRemovesitesinORFs{
									allsitestoavoid := make([]string, 0)
									part, err = sequences.RemoveSite(part, anysites.Enzyme, allsitestoavoid)
									if err != nil {
										warning = text.Print("Failed to remove "+ anysites.Enzyme.Name+" site from position "+strconv.Itoa(position)+". Position found to be outside of orf: "+orf.DNASeq, ". Error: "+err.Error())
										warnings = append(warnings, warning)
										Errorf(warning)
									}
								}
							}
						} else if !OnlyRemovesitesinORFs{
							allsitestoavoid := make([]string, 0)
							temppart, err := sequences.RemoveSite(part, anysites.Enzyme, allsitestoavoid)
				
							if err != nil {
								warning := fmt.Sprintf("Faiure to automatically remove %s site at positions %+v in part %s: %s! improve algorithm  or remove manually until you do!: %s",anysites.Enzyme.Name,anysites.Positions("ALL"),part.Nm, part.Seq,err.Error())
								warnings = append(warnings, warning)
								Errorf(warning)
	
							}
							warning = fmt.Sprintln("modified "+temppart.Nm+"new seq: ", temppart.Seq, "original seq: ",part.Seq)
							warnings = append(warnings, warning)
							part = temppart
	
						}
					}
					
					
				}
				newparts = append(newparts, part)

			}else{
				newparts = append(newparts, part)
				}
			
		}
		partsinorder = newparts
	}
	// export the parts list with sites removed
	PartsWithSitesRemoved = partsinorder
	// make vector into an antha type DNASequence
	
	
	if MakeLevel1Device != ""{
		
		standard, found := enzymes.EndlinksString[AssemblyStandard]
		
		if !found {
			Errorf("No assembly standard %s found",AssemblyStandard)
		}
		
		level1, found := standard["Level1"]
		
		if !found {
			Errorf("No Level1 found for standard %s",AssemblyStandard)
		}
		
		overhangs,found := level1[MakeLevel1Device]
		
		if !found {
			Errorf("No overhangs found for %s in standard %s",MakeLevel1Device,AssemblyStandard)
		}
		
		if len(overhangs)!= 2 {
			Errorf("found %d overhangs for %s in standard %s, expecting %d",len(overhangs), MakeLevel1Device,AssemblyStandard, 2)

		}
		
		if overhangs[0] == "" {
			Errorf("blunt 5' overhang found for %s in standard %s, expecting %d", MakeLevel1Device,AssemblyStandard, 2)
		}
		
		PartsWithSitesRemoved[0], err = enzymes.AddL1UAdaptor(PartsWithSitesRemoved[0],AssemblyStandard,"Level1",MakeLevel1Device,ReverseLevel1Orientation)
		if err != nil {
			Errorf(err.Error())
		}
	
		PartsWithSitesRemoved[len(PartsWithSitesRemoved)-1], err = enzymes.AddL1DAdaptor(PartsWithSitesRemoved[len(PartsWithSitesRemoved)-1],AssemblyStandard,"Level1",MakeLevel1Device,ReverseLevel1Orientation)
		if err != nil {
			Errorf(err.Error())
		}

	}
	//lookup restriction enzyme
	restrictionenzyme, err := lookup.TypeIIsLookup(enz.Name)
	if err != nil {
		warnings = append(warnings, text.Print("Error", err.Error()))
	}

	//  Add overhangs for scarfree assembly based on part seqeunces only, i.e. no Assembly standard
	fmt.Println("warnings:", warnings)
	
	if EndsAlreadyadded {
		PartswithOverhangs = partsinorder
	} else {
	//  Add standard overhangs using chosen assembly standard
	PartswithOverhangs, err = enzymes.MakeStandardTypeIIsassemblyParts(partsinorder, AssemblyStandard, Level, PartMoClotypesinorder)
	
	if err != nil{
		warnings = append(warnings, text.Print("Error", err.Error()))
		Errorf(err.Error())
	}
	
	}
	
	// Check that assembly is feasible with designed parts by simulating assembly of the sequences with the chosen enzyme
	assembly := enzymes.Assemblyparameters{Constructname, restrictionenzyme.Name, vectordata, PartswithOverhangs}
	status, numberofassemblies, _, newDNASequence, err := enzymes.Assemblysimulator(assembly)
	
	if err != nil {
		Errorf("Error simulating assembly of %s: %s ",Constructname, err.Error())
	}
	
	Insert, err = assembly.Insert()
	
	if err != nil {
		Errorf("Error calculating insert from assembly: %s. Sites at positions: %s ",err.Error(),siteReport(partsinorder,removetheseenzymes))
	}	
	
	// export parts + vector as one array
	for _, part := range PartswithOverhangs {
		PartsAndVector = append(PartsAndVector,part)
	}
	
	// now add vector 
	PartsAndVector = append(PartsAndVector,vectordata)

	endreport := "Endreport only run in the event of assembly simulation failure"
	//sites := "Restriction mapper only run in the event of assembly simulation failure"
	newDNASequence.Nm = Constructname
	NewDNASequence = newDNASequence
	if err == nil && numberofassemblies == 1 {

		Simulationpass = true
	}// else {

		warnings = append(warnings, status)
		// perform mock digest to test fragement overhangs (fragments are hidden by using _, )
		_, stickyends5, stickyends3 := enzymes.TypeIIsdigest(vectordata, restrictionenzyme)

		allends := make([]string, 0)
		ends := ""

		ends = text.Print(vectordata.Nm+" 5 Prime end: ", stickyends5)
		allends = append(allends, ends)
		ends = text.Print(vectordata.Nm+" 3 Prime end: ", stickyends3)
		allends = append(allends, ends)

		for _, part := range PartswithOverhangs {
			_, stickyends5, stickyends3 := enzymes.TypeIIsdigest(part, restrictionenzyme)
			ends = text.Print(part.Nm+" 5 Prime end: ", stickyends5)
			allends = append(allends, ends)
			ends = text.Print(part.Nm+" 3 Prime end: ", stickyends3)
			allends = append(allends, ends)
		}
		endreport = strings.Join(allends, " ")
		if !Simulationpass{
		warnings = append(warnings, endreport)
		}
//	}

	// check number of sites per part !

	sites := make([]int, 0)
	multiple := make([]string, 0)
	for _, part := range PartswithOverhangs {

		info := enzymes.Restrictionsitefinder(part, removetheseenzymes)

		for i := range info {
		sitepositions := enzymes.SitepositionString(info[i])

		sites = append(sites, info[i].Numberofsites)
		sitepositions = text.Print(part.Nm+" "+info[i].Enzyme.Name+" positions:", sitepositions)
		multiple = append(multiple, sitepositions)
		}
	}

	for _, orf := range ORFstoConfirm {
		if sequences.LookforSpecificORF(NewDNASequence.Seq, orf) == false {
			warning = text.Print("orf not present: ", orf)
			warnings = append(warnings, warning)
			ORFmissing = true
		}
	}

	if len(warnings) == 0 {
		warnings = append(warnings, "none")
	}
	Warnings = fmt.Errorf(strings.Join(warnings, ";"))
	Endreport = endreport
	PositionReport = multiple

	partsummary := make([]string, 0)
	for _, part := range PartswithOverhangs {
		partsummary = append(partsummary, text.Print(part.Nm, part.Seq))
	}
	partsummary = append(partsummary, text.Print("Vector:"+ vectordata.Nm, vectordata.Seq))
	partstoorder := text.Print("PartswithOverhangs: ", partsummary)
	

	// Print status
	if Status != "all parts available"{
		Status = fmt.Sprintln(Status)
	} else {Status = fmt.Sprintln(
		text.Print("simulator status: ", status),
		text.Print("Endreport after digestion: ",endreport),
		text.Print("Sites per part for " + enz.Name, sites),
		text.Print("Positions: ", multiple),
		text.Print("Warnings:", Warnings.Error()),
		text.Print("Simulationpass=", Simulationpass),
		text.Print("NewDNASequence: ",NewDNASequence),
		text.Print("Any Orfs to confirm missing from new DNA sequence:", ORFmissing),
		partstoorder,
		)
		// export data to file
		//anthapath.ExporttoFile("Report"+"_"+Constructname+".txt",[]byte(Status))
	//anthapath.ExportTextFile("Report"+"_"+Constructname+".txt",Status)
	fmt.Println(Status)
	}
	
	// export sequence to fasta
	if ExporttoFastaFile && Simulationpass{
		exportedsequences := make([]DNASequence,0)
		// add dna sequence produced
		exportedsequences = append(exportedsequences,NewDNASequence)
		if len(exportedsequences)==0{
			Errorf("No Sequences!")
		}
		// export to file
		AssembledSequenceFile,_, err = export.FastaSerial(export.LOCAL,filepath.Join(Constructname,"AssemblyProduct"), exportedsequences)
		if err != nil {
			Errorf(err.Error())
		}
		// reset 
		exportedsequences = make([]DNASequence,0)
		// add all parts with overhangs 
		for _,part := range PartswithOverhangs{
		exportedsequences = append(exportedsequences,part)	
		}
		PartsToOrderFile, _, err = export.FastaSerial(export.LOCAL,filepath.Join(Constructname,"Parts"), exportedsequences)
		if err != nil {
			Errorf(err.Error())
		}
	}
	
	
}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
}
