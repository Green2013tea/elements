//This element will work out and perform the dilutions necessary to make an antha palette.
protocol CreateAnthaPalette

import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/image"
	"github.com/antha-lang/antha/antha/anthalib/wunit"
	"fmt"
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"github.com/antha-lang/antha/microArch/factory"

)


// Input parameters for this protocol (data)
Parameters (
	AnthaPalette	*image.AnthaPalette	//AnthaPalette to be generated
	//ColorVolume		Volume				//Volume of each color on the palette you want to generate
	//PalettePlate	wtype.LHPlate		//Plate on which the palette will be generated
	LowerThreshold	int					//RGB value below which we do not create a color (we consider it nil). The number is between 0 and 65535.
)

// Data which is returned from this protocol, and data types
Data (
)


// Physical Inputs to this protocol with types
Inputs (

)

// Physical outputs from this protocol with types
Outputs (
	MixedAnthaPalette *image.AnthaPalette	//The palette with physical location information added to the LHComponents.
)

Requirements {
	
}

// Conditions to run on startup
Setup {
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	//----------------------------------------------------------------------------------
	//Globals
	//----------------------------------------------------------------------------------

	//This is the maximum reached by summing RGB values. We use this as a reference to get percentages values for each channels
	var maxRGB = 196605

	//TODO Those globals are set up for testing
	ColorVolume := wunit.NewVolume(10,"ul")

	PalettePlate := factory.GetPlateByType("pcrplate_skirted")


	//----------------------------------------------------------------------------------
	//Generating colors
	//----------------------------------------------------------------------------------

	//iterate over each colors in the palette
	for i := range AnthaPalette.Palette {

		//placeholder for the current color we are iterating over
		var currentAnthaColor = AnthaPalette.AnthaColors[i]
		//PlaceHolder for the LHComponent solution to be pipetted into the well
		var solution *LHComponent
		//PlaceHolder for the total well volume
		var totalVolume []Volume

		//extract RGBA values
		r,g,b,a := currentAnthaColor.Color.RGBA()

		//getting the volume of RGB needed
		vr := wunit.NewVolume((float64(r)/float64(maxRGB)) * ColorVolume.RawValue(),ColorVolume.Unit().PrefixedSymbol())
		vg := wunit.NewVolume((float64(g)/float64(maxRGB)) * ColorVolume.RawValue(),ColorVolume.Unit().PrefixedSymbol())
		vb := wunit.NewVolume((float64(b)/float64(maxRGB)) * ColorVolume.RawValue(),ColorVolume.Unit().PrefixedSymbol())

		fmt.Println(vr,vg,vb,a)

		//Check if the values for each colors is lower than the lowerThreshold defined
		if r <= uint32(LowerThreshold) && g <= uint32(LowerThreshold) && b <= uint32(LowerThreshold) {
			continue
		}else{
			//----------------------------------------------------------------------------------
			//Pipetting red
			//----------------------------------------------------------------------------------

			//Initiating the LHComponents to pipette with volume information
			rSample := mixer.Sample(currentAnthaColor.Component, vr)

			// if no other components are going to be added afterward, change the liquidtype to Mix else change to pipette above
			//TODO: why do you multiply by 4
			if wunit.AddVolumes(totalVolume).EqualTo(wunit.MultiplyVolume(ColorVolume,4)){
				rSample.Type = wtype.LTMegaMix
			}else{
				rSample.Type = wtype.LTDISPENSEABOVE
			}

			//since this is the first color to be pipetted, we use MixNamed to instantiate the LHComponent
			solution = MixNamed(PalettePlate.Type, "","Palette", rSample)

			//----------------------------------------------------------------------------------
			//Pipetting green
			//----------------------------------------------------------------------------------

			//Initiating the LHComponents to pipette with volume information
			gSample := mixer.Sample(currentAnthaColor.Component, vg)

			// if no other components are going to be added afterward, change the liquidtype to Mix else change to pipette above
			//TODO: why do you multiply by 4
			if wunit.AddVolumes(totalVolume).EqualTo(wunit.MultiplyVolume(ColorVolume,4)){
				gSample.Type = wtype.LTMegaMix
			}else{
				gSample.Type = wtype.LTDISPENSEABOVE
			}

			//if the solution is already instantiated, we add it with the Mix() command. Else we make a new one with MixNamed()
			if solution != nil {
				solution = Mix(solution, gSample)
			} else {
				solution = MixNamed(PalettePlate.Type, "","Palette", gSample)
			}

			//----------------------------------------------------------------------------------
			//Pipetting Blue
			//----------------------------------------------------------------------------------
			//Initiating the LHComponents to pipette with volume information
			bSample := mixer.Sample(currentAnthaColor.Component, vb)

			// if no other components are going to be added afterward, change the liquidtype to Mix else change to pipette above
			//TODO: why do you multiply by 4
			if wunit.AddVolumes(totalVolume).EqualTo(wunit.MultiplyVolume(ColorVolume,4)){
				bSample.Type = wtype.LTMegaMix
			}else{
				bSample.Type = wtype.LTDISPENSEABOVE
			}

			//if the solution is already instantiated, we add it with the Mix() command. Else we make a new one with MixNamed()
			if solution != nil {
				solution = Mix(solution, bSample)
			} else {
				solution = MixNamed(PalettePlate.Type, "","Palette", bSample)
			}

			//adding the final created LHComponent to the AnthaColor (since it has the added mixing information)
			AnthaPalette.AnthaColors[i].Component = solution

		}
	}

	//returning the AnthaPalette with updated LHComponents
	MixedAnthaPalette = AnthaPalette

}
// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
	
}

