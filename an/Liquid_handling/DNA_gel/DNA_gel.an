// This protocol will load DNA samples on an E-GEL for DNA analysis, and can take input from other protocols which exports an array of LHComponents.
protocol DNA_gel

import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"fmt"

)
// Input parameters for this protocol (data)
Parameters (
	ProjectName string //optionally define name of experiment
	LoadingDyeInSample bool //select true if DNA samples already contain Loading Dye
	Replicates int //define number of technical replicates
	WaterVol	Volume //specify volume of water to add to prime the E-Gel
	LadderVolume Volume //specify the volume of DNA ladder to add
	LoadingDyeVolume Volume //specify the volume of loading dye to add to each sample
	DNAGelRunVolume Volume //specify the total running volume of the E-Gel in use
	MixingPolicy string //default is Load policy but can be overriden by specifying here
)

// Data which is returned from this protocol, and data types
Data (
	Error error //error reporting
)


// Physical Inputs to this protocol with types
Inputs (
	Reactions []*wtype.LHComponent // This is the input that comes as the output from an upstream element (AutoAssembly.an)
  Water	*wtype.LHComponent //water
	Ladder *wtype.LHComponent //DNA ladder
	LoadingDye *wtype.LHComponent //loading dye to mix with samples
	DNAGel *wtype.LHPlate  // E-GEL type
	MixPlate *wtype.LHPlate// plate to mix samples if required
)

// Physical outputs from this protocol with types
Outputs (
	LoadedSamples []*wtype.LHComponent //samples outputted as an array which can be wired into downstream protocols

)

// No special requirements on inputs
Requirements {

}

// Condititions run on startup
// Including configuring an controls required, and the blocking level needed
// for them (in this case, per plate of samples processed)
Setup {

}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {

	//set up some arrays to fill and LHComponent variables for the DNA samples
	var loadedsamples []*wtype.LHComponent

	//setup variable for error reporting
	var err error

	//specify default mixing policy
	if MixingPolicy == "" {
		MixingPolicy = "Load"
	}

	//get well positions of DNA Gel from plate library ensuring the list is by row rather than by column
	var wells []string = DNAGel.AllWellPositions(wtype.BYROW)

	//setup liquid handling component variables
	var DNAGelloadmix *wtype.LHComponent
	var loadedsample *wtype.LHComponent

	//begin counter at first well position as E-GEL must be run upside down
	var counter int = len(wells)-1

	//work out and copy sample volume
	samplevolume := (wunit.CopyVolume(DNAGelRunVolume))

	//work out volume of water required
	samplevolume.Subtract(WaterVol)

	//assign water to specific liquid handling load type
	Water.Type = wtype.LTloadwater

		//calculate and loop through specified number of replicates
		for j:=0;j< Replicates;j++{

				//range through the reactions input array and perform specified actions
				for i := range Reactions {

						//sample water at specified water volume
						waterSample := mixer.Sample(Water,WaterVol)

						//update position to correspond to counter
						position := wells[counter]

						//get well coordinates from correct position
						wellcoords := wtype.MakeWellCoordsA1(position)

						//add ladder

						//if it is the last column, add a ladder sample
						fmt.Println(DNAGel.WlsX, wellcoords.X)
						if wellcoords.X == DNAGel.WlsX -1 {

							//attribute specified mixinpolicy to the DNA ladder
							Ladder.Type, err = wtype.LiquidTypeFromString(MixingPolicy)
							if err != nil {
								Errorf("Error in specifying MixingPolicy %s for DNA Gel: %s", MixingPolicy, err.Error())
							}

							//perform liquid handling for addiiton of ladder sample
							laddersample := MixInto(
																		DNAGel,
																		position,
																		mixer.SampleForTotalVolume(Water,DNAGelRunVolume),
																		mixer.Sample(Ladder, LadderVolume),
																	)

							//add ladder to array of loaded samples
							loadedsamples = append(loadedsamples,laddersample)

							//decrease counter by 1, as pipetting Gel backwards
							counter--

						}

						// refresh position in case ladder was added
						position = wells[counter]


						sampletotest := Reactions[i]

						// load sample

						// add loading dye if necessary
							if !LoadingDyeInSample {

								//attribute specified mixinpolicy to the LoadingDye
									LoadingDye.Type, err = wtype.LiquidTypeFromString("NeedToMix")
									if err != nil{
											Errorf(err.Error())
									}

									//perform liquid handling for addiiton and mixing of the loading dye
									DNAGelloadmixsolution := MixInto(
																									MixPlate,
																									"",
																									mixer.Sample(sampletotest,samplevolume),
																									mixer.Sample(LoadingDye,LoadingDyeVolume),
																									)
									DNAGelloadmix = DNAGelloadmixsolution
							} else {
									DNAGelloadmix = sampletotest
							}

							//attribute specified mixinpolicy to the samples
						DNAGelloadmix.Type, err = wtype.LiquidTypeFromString(MixingPolicy)
						if err != nil {
							Errorf("Error in specifying MixingPolicy %s for DNA Gel: %s", MixingPolicy, err.Error())
						}

						//load the DNA samples (either mixed with loading dye or pre-mixed) to the E-GEL
						loadedsample = MixInto(
																	DNAGel,
																	position,
																	waterSample,
																	mixer.Sample(DNAGelloadmix, samplevolume),
																	)
						//add the loaded samples to the loadedsamples array
						loadedsamples = append(loadedsamples,loadedsample)

						//decrease counter by 1 as loading the E-Gel backwards becuase of position constraints
						counter--

				}

}
	//update output variable LoadedSamples with the output of the protocol
	LoadedSamples = loadedsamples
}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {

}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {

}
