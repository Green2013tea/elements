// Protocol to make a serial dilution series from a solution and diluent
protocol SerialDilution


import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"	
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"github.com/antha-lang/antha/antha/anthalib/wunit"
)


// Input parameters for this protocol (data)
Parameters (
	// This is the final volume that you will achieve after the dilutions have been performed.
	TotalVolumeperDilution Volume
	// The dilution factor to be applied to the serial dilution, e.g. 10 would take 1 part solution to 9 parts diluent for each dilution. 
	DilutionFactor  float64
	// The number of dilutions you wish to make.
	NumberOfDilutions int
	// An optional parameter to define whether you want your dilutions to be made in rows or columns in your plate.
	ByRow bool
	// If using a plate that already has solutions in other wells you can specify from which well you want your serial dilution to start from.
	WellsAlreadyUsed int
	// Option to remove the excess solution volume in the last dilution to the input plate if equal volumes across all dilutions are desired.
	RemoveExcessSolution bool
	// This name will be used as the identifier for the specific plate you are making your Serial Dilutions to. If running more than one instance of the Serial Dilution element in parallel and want the dilutions to all be made on the same plate be sure this name is the same across all instance parameter sets. 
	DilutionPlateName string
)

// Data which is returned from this protocol, and data types
Data (
	// How many wells were used by this element in your output plate.
	WellsUsed int
)


// Physical Inputs to this protocol with types
Inputs (
	// The physical solution you wish to serially dilute, e.g. BSA, DNA, Glucose.
	Solution *LHComponent
	// The physical solution you want to make your dilutions into, e.g. water, Buffer.
	Diluent *LHComponent
	//The physical plate where your serial dilutions will be made.
	OutPlate *LHPlate
)

// Physical outputs from this protocol with types
Outputs (
	// The physical dilutions made by this element.
	Dilutions []*LHComponent
)

Requirements {
	
}

// Conditions to run on startup
Setup {
	
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	
	// This code allows the user to specify how the Serial Dilutions should be made in order, by row or by column.
	allwellpositions := OutPlate.AllWellPositions(ByRow)
	var counter int = WellsAlreadyUsed

	// Create a slice to store our liquid handling instructions for all our serial dilutions.
	dilutions := make([]*LHComponent,0)

	// Create a variable to store the liquid handling instructions for a single dilution
	var firstDilution *LHComponent
	
	// calculate solution volume
	
	// create copy of TotalVolumeperDilution
	solutionVolume := (wunit.CopyVolume(TotalVolumeperDilution))
	
	// use divideby method
	solutionVolume.DivideBy(DilutionFactor - 1.00) 
	
	// create a slice to hold all the volumes
	var volumes []Volume
	
	// add all the volumes to the slice
	volumes = append(volumes, solutionVolume)
	volumes = append(volumes, TotalVolumeperDilution)
	
	// calculate the total volume for the intermediate dilution
	totalVolume := wunit.AddVolumes(volumes)
	
	// check the volume of the plate type selected for each well against the intermediate dilution total volume. If it is exceeded report an error identifying the discrepancy
	if OutPlate.Welltype.MaxVolume().LessThanRounded(totalVolume, 7) {
		Errorf("Intermediate dilution volume calculated: (%s) too high for well capacity (%s) of current plate (%s)", totalVolume.ToString(), OutPlate.Welltype.MaxVolume().ToString(), OutPlate.Type)
	}
	
	
	// sample diluent
	diluentSample := mixer.Sample(Diluent,TotalVolumeperDilution)
		
	// Ensure liquid type set to Pre and Post Mix 
	Solution.Type = wtype.LTNeedToMix		
	
	// sample solution
	solutionSample := mixer.Sample(Solution,solutionVolume)
	
	// mix both diluent and sample to OutPlate
	firstDilution = MixNamed(OutPlate.Type, allwellpositions[counter], DilutionPlateName, diluentSample, solutionSample)
	
	// Create a variable to store the solution name in
	var solutionname string
	
	// Create a variable to store the calculated concentration per solution
	var newconcentration Concentration
	
	// If the Stock Solution has a concentration associated with it then rename the diluted solution with its new concentration
	if Solution.HasConcentration() {
		
		// extract the solution name as a string and store in our solution name variable
		solutionname = Solution.CName
		
		// extract the solution concentration as a string and store in our solution concentration variable
		solutionConcentration := Solution.Concentration()
		
		// Calculate the new concentration after dilution by dividing the solution concentration by the dilution factor
		newconcentration = wunit.DivideConcentration(solutionConcentration, float64(DilutionFactor))
		
		// Rename the first dilution sample to contain the concentration in its name
		firstDilution.CName = newconcentration.ToString() + " " + solutionname
		
		// Normalise the name to a format that can be parsed for DOE elements
		firstDilution.CName = normalise(firstDilution.CName)
	}

	
	// add to dilutions array
	dilutions = append(dilutions,firstDilution)
	
	// add 1 to our counter to keep track of the number of wells that have been used
	counter++
	
	// loop through NumberOfDilutions until all serial dilutions are made
	for k := 1; k < NumberOfDilutions; k++ {
		
		// take next sample of diluent
		nextDiluentSample := mixer.Sample(Diluent, TotalVolumeperDilution)
		
		// Ensure liquid type set to Pre and Post Mix 
		firstDilution.Type = wtype.LTNeedToMix
		
		// sample from previous dilution sample
		nextSample := mixer.Sample(firstDilution, solutionVolume)
		
		// Mix sample into nextdiluent sample
		nextDilution := MixNamed(OutPlate.Type, allwellpositions[counter], DilutionPlateName, nextDiluentSample, nextSample)
		
		if newconcentration.RawValue() > 0  {
		// Calculate the conc entration for the next dilution based on the concentration of the previous dilution
		nextconcentration := wunit.DivideConcentration(newconcentration, float64(DilutionFactor))
		
		// Rename the next dilution sample to show its new concentration
		nextDilution.CName = nextconcentration.ToString() + " " + solutionname
		
		// Normalise the name to a format that can be parsed for DOE elements
		nextDilution.CName = normalise(nextDilution.CName)
		
		// Set the new concentration to the next concentration calculated ready for the next round of the loop
		newconcentration = nextconcentration
		}
		
		// add to dilutions array 
		dilutions = append(dilutions,nextDilution)
		
		// reset aliquot
		firstDilution = nextDilution
		
		// add 1 to the counter to keep track of the wells used in our output plate
		counter++
		}
		
		// Option to remove the excess solution volume in the last dilution to the input plate if equal volumes across all dilutions are desired.
		if RemoveExcessSolution {
		// Remove the aditional solution volume from the final dilution and move it to the input plate such that the final dilution volume equals the user defined final volume.
		disposeSample := mixer.Sample(firstDilution, solutionVolume)
		Mix(disposeSample)
		}
// export as Output
Dilutions = dilutions 

// Output the number of wells that have been used on this plate
WellsUsed = counter

}
// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
	
}

