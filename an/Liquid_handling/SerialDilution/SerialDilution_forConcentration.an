// Protocol to make a serial dilution series targeting a series of specified concentrations from a solution of known Stock concentration and a diluent.
// The next dilution in the series will always be made from the previous dilution and not from the original stock solution.
protocol SerialDilution_forConcentration


import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"	
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"strings"
)

// Input parameters for this protocol (data)
Parameters (
	StartVolumeperDilution 	Volume 
	StockConcentration		Concentration // specify a starting concentration
	TargetConcentrations  	[]Concentration// e.g. 10 would take 1 part solution to 9 parts diluent for each dilution 
	ByRow 					bool // optionally choose whether to aliqout the serial dilutions by row instead of the default by column
	WellsAlreadyUsed		int // optionally start after a specified well position if wells are allready used in the plate
)

// Data which is returned from this protocol, and data types
Data (
	AllConcentrations []Concentration
	ComponentNames []string
	WellsUsedPostRun		int
)


// Physical Inputs to this protocol with types
Inputs (
	Solution *wtype.LHComponent 
	Diluent *wtype.LHComponent
	OutPlate *wtype.LHPlate
)

// Physical outputs from this protocol with types
Outputs (
	Dilutions []*wtype.LHComponent // dilutions only
	AllDilutions []*wtype.LHComponent // original solution + dilutions
)

Requirements {
	
}

// Conditions to run on startup
Setup {
	
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	
	allwellpositions := OutPlate.AllWellPositions(ByRow)
	
	var counter int = WellsAlreadyUsed
	var dilutionPosition int = 0
	
	dilutions := make([]*wtype.LHComponent,0)

	var aliquot *wtype.LHComponent
	
	// calculate solution volume
	solutionVolume,err := wunit.VolumeForTargetConcentration(TargetConcentrations[dilutionPosition],StockConcentration,StartVolumeperDilution)
	
		if err != nil{
			Errorf(err.Error())
		}
	
	// use same approach to work out diluent volume to add	
	diluentVolume := (wunit.CopyVolume(StartVolumeperDilution))
	
	// this time using the substract method
	diluentVolume.Subtract(solutionVolume)	
	
	// sample diluent
	diluentSample := mixer.Sample(Diluent,diluentVolume)
		
	// Ensure liquid type set to Pre and Post Mix 
	Solution.Type = wtype.LTNeedToMix
	// check if the enzyme is specified and if not mix the 
		
	// sample solution
	solutionSample := mixer.Sample(Solution,solutionVolume)
	
	// mix both samples to OutPlate
	aliquot = MixNamed(OutPlate.Type,allwellpositions[counter], "DilutionPlate",diluentSample, solutionSample)

	var solutionname string
	
	// rename sample to include concentration
	containsconc, _, componentNameOnly := wunit.ParseConcentration(Solution.CName)
	
	if containsconc{
		solutionname = componentNameOnly
	}
	
	aliquot.CName = TargetConcentrations[dilutionPosition].ToString() + " " +solutionname
	aliquot.CName = normalise(aliquot.CName)
	aliquot.SetConcentration(TargetConcentrations[dilutionPosition])
		
	// add to dilutions array
	dilutions = append(dilutions,aliquot)
	
	// loop through NumberOfDilutions until all serial dilutions are made
	
	counter++
	dilutionPosition++
	
	for dilutionPosition  < len(TargetConcentrations) {
		
			// calculate new solution volume
		solutionVolume,err := wunit.VolumeForTargetConcentration(TargetConcentrations[dilutionPosition],TargetConcentrations[dilutionPosition-1],StartVolumeperDilution)
		
			if err != nil{
				Errorf(err.Error())
			}
		
		// use same approach to work out diluent volume to add	
		diluentVolume = (wunit.CopyVolume(StartVolumeperDilution))
		
		// this time using the substract method
		diluentVolume.Subtract(solutionVolume)	
			
		// take next sample of diluent
		nextdiluentSample := mixer.Sample(Diluent, diluentVolume)
		
		nextdiluentSample = MixNamed(OutPlate.Type,allwellpositions[counter], "DilutionPlate",nextdiluentSample)
		
		// Ensure liquid type set to Pre and Post Mix 
		aliquot.Type = wtype.LTNeedToMix
		
		// sample from previous dilution sample
		nextSample := mixer.Sample(aliquot, solutionVolume)
		
		// Mix sample into nextdiluent sample
		nextaliquot := Mix(nextdiluentSample,nextSample)
		
		// rename sample to include concentration
		nextaliquot.CName = TargetConcentrations[dilutionPosition].ToString()+" " +solutionname
		
		nextaliquot.CName = normalise(nextaliquot.CName)
		
		nextaliquot.SetConcentration(TargetConcentrations[dilutionPosition])
		// add to dilutions array 
		dilutions = append(dilutions,nextaliquot)
		// reset aliquot
		aliquot = nextaliquot
		
		counter++ 
		dilutionPosition++
	}
		
// export as Output
Dilutions = dilutions


// export all concentrations used as export
AllDilutions = append(AllDilutions,Solution)
AllConcentrations = append(AllConcentrations, StockConcentration)

Solution.CName = StockConcentration.ToString()+ " " +solutionname
Solution.CName = normalise(Solution.CName)
ComponentNames = append(ComponentNames, Solution.CName)
for i, dilution := range Dilutions {
	
	AllDilutions = append(AllDilutions,dilution)
	ComponentNames = append(ComponentNames, dilution.CName)
	AllConcentrations = append(AllConcentrations, TargetConcentrations[i])
	
} 



WellsUsedPostRun = counter

}

// if the component name contains a concentration the concentration name will be normalised
// e.g. 10ng/ul glucose will be normalised to 10 mg/l glucose or 10mM glucose to 10 mM/l glucose or 10mM/l glucose to 10 mM/l glucose or glucose 10mM/l to 10 mM/l glucose
func normalise(name string)(normalised string){
	
	if strings.Contains(name, wtype.MIXDELIMITER){
		return name
	}
	
	containsConc, conc, nameonly := wunit.ParseConcentration(name)
	
	if containsConc {
		return conc.ToString() + " " + nameonly
	}else {	
		return nameonly
	}
}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
	
}

