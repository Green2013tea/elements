// Protocol to make a serial dilution series targeting a series of specified concentrations from a solution of known Stock concentration and a diluent.
// The next dilution in the series will always be made from the previous dilution and not from the original stock solution.
protocol SerialDilution_Conc_Advanced

import (
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/antha/anthalib/wunit"
	"strconv"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/search"
	"fmt"
)

// Input parameters for this protocol (data)
Parameters (
	// This is the final volume each dilution will achieve.
	FinalVolumePerDilution Volume
	// Specify a stock concentration for your solution. If your physical solution is wired in from Add_Solution this parameter will be set to the concentration defined in Add_Solution.
	StockConcentration Concentration 
	// This is a list of concentrations you wish to achieve ranging from highest to lowest concentration.
	TargetConcentrations []Concentration
	// Optionally choose whether to aliqout the serial dilutions by row instead of the default by column.
	ByRow bool
	// Optionally start after a specified well position if wells are allready used in the plate. Fill in by listing all wells previously used (e.g. A1, A2, B3, D4, etc. Or wire in a WellsUsed output from another element.
	WellsAlreadyUsed map[string][]string
	// This will set the number of replica plates that your dilutions will be made to. (Set to 1 for one plate, 2 for two plates, etc.)
	NumberOfReplicatePlates int
	// Optionally include your stock solution as your first dilution.
	IncludeStockSolution bool
	// This name will be used as the identifier for the specific plate you are making your dilutions to appended with the replica plate number. If left blank it will default to DilutionPlate. If running more than one instance of the SerialDilutiom element in parallel and you want the dilutions to all be made on the same plate be sure this name is the same across all instance parameter sets, and be sure to wire WellsAlreadyUsed into WellsUsed between the different instances.
	DilutionPlateName string
)

// Data which is returned from this protocol, and data types
Data (
	// How many wells were used by this element in your output plate.
	WellsUsed map[string][]string
)

// Physical Inputs to this protocol with types
Inputs (
	// The physical solution you wish to serially dilute, e.g. BSA, DNA, Glucose.
	Solution *LHComponent
	// The physical solution you want to make your dilutions into, e.g. water, Buffer.
	Diluent *LHComponent
	//The physical plate where your serial dilutions will be made.
	OutPlate *LHPlate
)

// Physical outputs from this protocol with types
Outputs (
	// The physical dilutions made by this element.
	Dilutions []*LHComponent    // dilutions only
)

Requirements {

}

// Conditions to run on startup
Setup {

}

// The core process for this protocol, with the steps to be performed.
// for every input
Steps {
	
	// Initialise all variables, slices and maps required in this element for various calculations.
	
	// Used to set the size of other slices and also for selecting specific index positions in those slices.
	index := len(TargetConcentrations)
	
	// Used to store all the calculated Solution Volumes required by each dilution.
	SolutionVolumes := make([]Volume, index)
	
	// Used to store a single solution volume at a time to use in the volume arithmetic functions.
	SolutionVolume := make([]Volume, 1)
	
	// Used to store all the calculated Diluent Volumes required by each dilution.
	DiluentVolumes := make([]Volume, index)

	// Used to store a calculated Solution Volume and the user defined final volume to calculate the total volume required by the previous dilution.
	SampleVolumes := make([]Volume, 2)
	
	// Stores the calculated dilution factors to get from the concentration of one dilution to the next dilution concentration.
	dilutionFactors := make([]float64, (index))
	
	// Make a map of platenames to wells used in those plates.
	WellsUsed = make(map[string][]string)	
	
	// In order for this element to reach a desired volunme for all dilutions given different target concentrations
	// the volumes for all Soultions and Diluents for each dilution need to be calculated backwards from the last dilution back to the first.
	// Therefore first calculate the Solution and Diluent Volumes required for the last dilution.
	
	// Calculate the dilution factor to get from the penultimate dilution concentration to the last dilution concentration.
	lastDilutionFactor := TargetConcentrations[index - 2].SIValue()/TargetConcentrations[index - 1].SIValue()
	
	// Store the calculated dilution factor in the last index position of dilutionFactors.
	dilutionFactors[index - 1] = lastDilutionFactor
	
	// Calculate the Solution Volume required to reach the target concentration in the final volume specified and store in the last index position of the solutionVolumes slice.
	SolutionVolumes[index - 1] = wunit.DivideVolume(FinalVolumePerDilution, dilutionFactors[index - 1])
	
	// Copy that single volume over to a new slice for using in arimetic volume functions.
	SolutionVolume[0] = SolutionVolumes[index - 1]
	
	// Repeat the process for last Diluent Volume.
	DiluentVolumes[index - 1] = wunit.SubtractVolumes(FinalVolumePerDilution, SolutionVolume)
	
	// Store the solution volume and user defined sample volume in an array for arithmetic volume function.
	SampleVolumes[0]=SolutionVolumes[index - 1]
	SampleVolumes[1]=FinalVolumePerDilution
	
	// Calculate the target volume that will be required for the previous dilution in the series.
	NewTargetVolumePerDilution := wunit.AddVolumes(SampleVolumes)
	
	// check the volume of the plate type selected for each well against the intermediate dilution total volume. If it is exceeded report an error identifying the discrepancy.
		if OutPlate.Welltype.MaxVolume().LessThanRounded(NewTargetVolumePerDilution, 7) {
			Errorf("Intermediate dilution volume calculated: (%s) too high for well capacity (%s) of current plate (%s)", NewTargetVolumePerDilution.ToString(), OutPlate.Welltype.MaxVolume().ToString(), OutPlate.Type)
		}
	
	// Now the last dilution volumes are defined and the new target volume is calculated we can work backwards through the target concentration slice calculating all preceding dilutions in the same manner as above.
	for i := len(TargetConcentrations)-2; i >=1; i-- {
		DilutionFactor := TargetConcentrations[i-1].SIValue()/TargetConcentrations[i].SIValue()
		dilutionFactors[i] = DilutionFactor
		SolutionVolumes[i] = wunit.DivideVolume(NewTargetVolumePerDilution, DilutionFactor)
		SolutionVolume[0]=SolutionVolumes[i]
		DiluentVolumes[i] = wunit.SubtractVolumes(NewTargetVolumePerDilution, SolutionVolume)
		SampleVolumes[0]=SolutionVolumes[i]
		SampleVolumes[1]=FinalVolumePerDilution
		NewTargetVolumePerDilution = wunit.AddVolumes(SampleVolumes)
		// check the volume of the plate type selected for each well against the intermediate dilution total volume. If it is exceeded report an error identifying the discrepancy
		if OutPlate.Welltype.MaxVolume().LessThanRounded(NewTargetVolumePerDilution, 7) {
			Errorf("Intermediate dilution volume calculated: (%s) too high for well capacity (%s) of current plate (%s)", NewTargetVolumePerDilution.ToString(), OutPlate.Welltype.MaxVolume().ToString(), OutPlate.Type)
		}
		
	}
	
	// Finally calculate the first dilution volumes required when making this dilution from the supplied stock solution rather than the previous dilution.
	FirstDilutionFactor := StockConcentration.SIValue()/TargetConcentrations[0].SIValue()
	dilutionFactors[0] = FirstDilutionFactor
	SolutionVolumes[0] = wunit.DivideVolume(NewTargetVolumePerDilution, dilutionFactors[0])
	SolutionVolume[0]= SolutionVolumes[0]
	DiluentVolumes[0] = wunit.SubtractVolumes(NewTargetVolumePerDilution, SolutionVolume)
	SampleVolumes[0]=SolutionVolumes[0]
	SampleVolumes[1]=FinalVolumePerDilution
	NewTargetVolumePerDilution = wunit.AddVolumes(SampleVolumes)	
	
	// check the volume of the plate type selected for each well against the intermediate dilution total volume. If it is exceeded report an error identifying the discrepancy
		if OutPlate.Welltype.MaxVolume().LessThanRounded(NewTargetVolumePerDilution, 7) {
			Errorf("Intermediate dilution volume calculated: (%s) too high for well capacity (%s) of current plate (%s)", NewTargetVolumePerDilution.ToString(), OutPlate.Welltype.MaxVolume().ToString(), OutPlate.Type)
		}	
	
	// This code allows the user to specify how the Serial Dilutions should be made in order, by row or by column.
	allwellpositions := OutPlate.AllWellPositions(ByRow)
	
	// Create a slice to store our liquid handling instructions for all our serial dilutions.
	dilutions := make([]*LHComponent, 0)

	// This code checks to make sure the number of replica plates is greater than 0.
	if NumberOfReplicatePlates < 1 {
		Errorf("Number of replica plates must be greater than 0")
	}

	// Initialise the variables required for handling the liquid handling components.
 	var stockSolution *LHComponent
	var nextdilution *LHComponent
	var solutionSample *LHComponent

	// This loop allows the user to specify the number of replicate plates of aliquots they want.
	for platenumber := 1; platenumber < (NumberOfReplicatePlates + 1); platenumber++ {

		// Here we are initialising the platename variable used for renaming plates based off replicates
		var platename string

		// Here we are setting the DilutionPlateName to default to DilutionPlate if left blank by the user
		if DilutionPlateName == "" {
			DilutionPlateName = "DilutionPlate"
		} else {

			// If more than one replicate plate rename including platenumber
			if platenumber > 1 {
				platename = DilutionPlateName + strconv.Itoa(platenumber)
			} else {
				platename = DilutionPlateName
			}
		}

		// Populate the WellsUsed map with platenames and the wells already used from plates with the same name from other runs
		WellsUsed[platename] = append(WellsUsed[platename], WellsAlreadyUsed[platename]...)

		// Create a variable to store the solution name in
		var solutionname string

		// Create a variable to store the calculated concentration per solution
		var solutionConcentration Concentration

	// If the user wants to include the Stock solution as the first dilution transfer the stock solution of volume calculated previously providing enough solution for the next dilution to leave the terget volume.
	if IncludeStockSolution{
		
		// Create the stock solution sample
		stockSolutionSample := mixer.Sample(Solution, NewTargetVolumePerDilution)
		
		// check the outplate for wells already used and find the next free well
		well, _ := findNextFreeWell(allwellpositions, WellsUsed[platename])

		// Mix the stock solution to the next free well in our named outplate
		stockSolution = MixNamed(OutPlate.Type, well, platename, stockSolutionSample)

		// Ensure liquid type set to Pre and Post Mix
		stockSolution.Type = wtype.LTNeedToMix

		// update the wells used map to account for this well in this plate
		WellsUsed[platename] = append(WellsUsed[platename], well)
		
		// If the Stock Solution has a concentration associated with it (e.g. the solution is provided by the Add_Solutions element) then rename the diluted solution with its new concentration
		if Solution.HasConcentration() {

			// extract the solution name as a string and store in our solution name variable
			solutionname = Solution.CName

			// extract the solution concentration as a string and store in our solution concentration variable
			solutionConcentration = Solution.Concentration()			
			
			// Rename the first dilution sample to contain the concentration in its name
			stockSolution.CName = solutionConcentration.ToString() + " " + solutionname

			// Normalise the name to a format that can be parsed for DOE elements
			stockSolution.CName = normalise(stockSolution.CName)
		
		// if not then set the concentration to the user defined stock concentration and rename the sample using this.
		} else {
			
			// extract the solution name as a string and store in our solution name variable
			solutionname = Solution.CName

			// extract the solution concentration as a string and store in our solution concentration variable
			solutionConcentration = StockConcentration
			
			// Rename the first dilution sample to contain the concentration in its name
			stockSolution.CName = StockConcentration.ToString() + " " + solutionname

			// Normalise the name to a format that can be parsed for DOE elements
			stockSolution.CName = normalise(stockSolution.CName)

		}
		
		// Add the stock solution mix to the dilutions slice
		dilutions = append(dilutions, stockSolution)
	
	// If the user doesnt want the stock solution as part of their dilution series miss out the sample and mix steps for the stock solution but check for solution concentration either in the component or the user specified Stock Concentration for renaming purposes later.
	} else {
		if Solution.HasConcentration(){
			solutionConcentration = Solution.Concentration()
		} else {
			solutionConcentration = StockConcentration
		}
	}

	// Start looping through our calculated volume slices to sample and mix our subsequent dilutions.
	for i:=0; i < len(SolutionVolumes); i++{
		
		diluentSample := mixer.Sample(Diluent, DiluentVolumes[i])
		
		// Ensure liquid type set to Pre and Post Mix
		Solution.Type = wtype.LTNeedToMix
		
		// If in the first step of the loop the user wants to include the stock solution then make the next dilution from this sample from the first well used, not from the input plate.
		if i == 0 {
		if IncludeStockSolution {
		
		// sample stock solution
		solutionSample = mixer.Sample(stockSolution, SolutionVolumes[i])
		
		// If there is no stock solution as the first dilution then sample the first solution from the input plate.
		} else {
		solutionSample = mixer.Sample(Solution, SolutionVolumes[i])
			} 
			
			// Once past the first stage of the loop sample from the previous dilution.
			} else {
				solutionSample = mixer.Sample(nextdilution, SolutionVolumes[i])
			}
		
		// check the outplate for wells already used and find the next free well
		well, _ := findNextFreeWell(allwellpositions, WellsUsed[platename])
		
		// mix both diluent and sample to OutPlate
		dilution := MixNamed(OutPlate.Type, well, platename, diluentSample, solutionSample)
		
		// Ensure liquid type set to Pre and Post Mix
		dilution.Type = wtype.LTNeedToMix
		
		// set the next dilution to be the previous dilution for sampling from
		nextdilution = dilution
		
		// store all of the used wells in the WellsUsed slice.
		WellsUsed[platename] = append(WellsUsed[platename], well)
		
		// Calculate the concentration for the next dilution based on the concentration of the previous dilution
				nextconcentration := wunit.DivideConcentration(solutionConcentration, dilutionFactors[i])

				// Rename the next dilution sample to show its new concentration
				dilution.CName = nextconcentration.ToString() + " " + solutionname

				// Normalise the name to a format that can be parsed for DOE elements
				dilution.CName = normalise(dilution.CName)

				// Set the new concentration to the next concentration calculated ready for the next round of the loop
				solutionConcentration = nextconcentration
		
		// add each new dilution to the dilutions slice		
		dilutions = append(dilutions, dilution)
		}
		}
			
	//Output the physical dilutions.
	Dilutions = dilutions
	}
	
	// Check the wells that have already been used in this plate to be sure not to pipette on top of a previous solution. This is predominantly used for when two aliquot elements are used in serial to make sure the second set of aliquots are not pipette onto the first set.
func findNextFreeWell(allWellPositions []string, wellsUsed []string) (well string, err error) {

	for _, well := range allWellPositions {
		// If a well position is found to already have been used then add one to our counter that specifies the next well to use. See step 2 of the following comments.
		if !search.InSlice(well, wellsUsed) {
			return well, nil
		}
	}
	return
}

	
// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {

}
