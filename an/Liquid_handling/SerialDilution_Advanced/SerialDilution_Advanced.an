// Protocol to make a serial dilution series from a solution and diluent
protocol SerialDilution_Advanced


import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"	
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"github.com/antha-lang/antha/antha/anthalib/wunit"
	"strconv"
	//"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/search"

)


// Input parameters for this protocol (data)
Parameters (
	// This is the final volume that you will achieve after the dilutions have been performed.
	TotalVolumeperDilution Volume
	// The dilution factor to be applied to the serial dilution, e.g. 10 would take 1 part solution to 9 parts diluent for each dilution. 
	DilutionFactor  float64
	// The number of dilutions you wish to make.
	NumberOfDilutions int
	// An optional parameter to define whether you want your dilutions to be made in rows or columns in your plate.
	ByRow bool
	// If using a plate that already has solutions in other wells you can specify from which well you want your serial dilution to start from.
	WellsAlreadyUsed []string
	// Option to remove the excess solution volume in the last dilution to the input plate if equal volumes across all dilutions are desired.
	RemoveExcessSolution bool
	// This parameter sets the number of replica plates to perform aliquots to. Default number of plates is 1.
	NumberOfReplicaPlates int
	// This name will be used as the identifier for the specific plate you are making your dilutions to appended with the replica plate number. If left blank it will default to DilutionPlate. If running more than one instance of the SerialDilutiom element in parallel and you want the dilutions to all be made on the same plate be sure this name is the same across all instance parameter sets, and be sure to wire WellsAlreadyUsed into WellsUsed between the different instances.
	DilutionPlateName string
)

// Data which is returned from this protocol, and data types
Data (
	// How many wells were used by this element in your output plate.
	WellsUsed []string
)


// Physical Inputs to this protocol with types
Inputs (
	// The physical solution you wish to serially dilute, e.g. BSA, DNA, Glucose.
	Solution *LHComponent
	// The physical solution you want to make your dilutions into, e.g. water, Buffer.
	Diluent *LHComponent
	//The physical plate where your serial dilutions will be made.
	OutPlate *LHPlate
)

// Physical outputs from this protocol with types
Outputs (
	// The physical dilutions made by this element.
	Dilutions []*LHComponent
)

Requirements {
	
}

// Conditions to run on startup
Setup {
	
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	
	// This code allows the user to specify how the Serial Dilutions should be made in order, by row or by column.
	allwellpositions := OutPlate.AllWellPositions(ByRow)

	// Create a slice to store our liquid handling instructions for all our serial dilutions.
	dilutions := make([]*LHComponent,0)

    // This code checks to make sure the number of replica plates is greater than 0.
	if NumberOfReplicaPlates < 1 {
	Errorf("Number of replica plates must be greater than 0")
	}

	// Create a variable to store the liquid handling instructions for a single dilution
	var firstDilution *LHComponent
	
	// If wells have already been used and wired to this element from a previous element append them to the WellsUsed slice
	WellsUsed = append(WellsUsed, WellsAlreadyUsed...)
	
	// This loop allows the user to specify the number of replica plates of aliquots they want.
	for platenumber := 1; platenumber < (NumberOfReplicaPlates + 1); platenumber++ {
	
	// Here we are setting the DilutionPlateName to default to DilutionPlate if left blank by the user
		if DilutionPlateName == "" {
			DilutionPlateName = "DilutionPlate"
		}
		
	// Here we are renaming the Aliquot plate to account for replica plates. e.g. if there are no replicas then plate name will be set to "AliquotPlate" if there are 2 replicas then plate name will be set to "AliquotPlate1" and "AliquotPlate2", etc.
				platename := (DilutionPlateName + strconv.Itoa(platenumber))
	
	// calculate solution volume
	
	// create copy of TotalVolumeperDilution
	solutionVolume := (wunit.CopyVolume(TotalVolumeperDilution))
	
	// use divideby method
	solutionVolume.DivideBy(DilutionFactor - 1.00) 
	
	// create a slice to hold all the volumes
	var volumes []Volume
	
	// add all the volumes to the slice
	volumes = append(volumes, solutionVolume)
	volumes = append(volumes, TotalVolumeperDilution)
	
	// calculate the total volume for the intermediate dilution
	totalVolume := wunit.AddVolumes(volumes)
	
	// check the volume of the plate type selected for each well against the intermediate dilution total volume. If it is exceeded report an error identifying the discrepancy
	if OutPlate.Welltype.MaxVolume().LessThanRounded(totalVolume, 7) {
		Errorf("Intermediate dilution volume calculated: (%s) too high for well capacity (%s) of current plate (%s)", totalVolume.ToString(), OutPlate.Welltype.MaxVolume().ToString(), OutPlate.Type)
	}
	
	
	// sample diluent
	diluentSample := mixer.Sample(Diluent,TotalVolumeperDilution)
		
	// Ensure liquid type set to Pre and Post Mix 
	Solution.Type = wtype.LTNeedToMix		
	
	// sample solution
	solutionSample := mixer.Sample(Solution,solutionVolume)
	
	well, _ := findNextFreeWell(allwellpositions, WellsUsed)
	
	// mix both diluent and sample to OutPlate
	firstDilution = MixNamed(OutPlate.Type, well, platename, diluentSample, solutionSample)
	
	// store all of the used wells in the WellsUsed slice.
				WellsUsed = append(WellsUsed, well)
				
	// Create a variable to store the solution name in
	var solutionname string
	
	// Create a variable to store the calculated concentration per solution
	var newconcentration Concentration
	
	// If the Stock Solution has a concentration associated with it then rename the diluted solution with its new concentration
	if Solution.HasConcentration() {
		
		// extract the solution name as a string and store in our solution name variable
		solutionname = Solution.CName
		
		// extract the solution concentration as a string and store in our solution concentration variable
		solutionConcentration := Solution.Concentration()
		
		// Calculate the new concentration after dilution by dividing the solution concentration by the dilution factor
		newconcentration = wunit.DivideConcentration(solutionConcentration, float64(DilutionFactor))
		
		// Rename the first dilution sample to contain the concentration in its name
		firstDilution.CName = newconcentration.ToString() + " " + solutionname
		
		// Normalise the name to a format that can be parsed for DOE elements
		firstDilution.CName = normalise(firstDilution.CName)
	}

	
	// add to dilutions array
	dilutions = append(dilutions,firstDilution)
	
	
	// loop through NumberOfDilutions until all serial dilutions are made
	for k := 1; k < NumberOfDilutions; k++ {
	
		
		
		// take next sample of diluent
		nextDiluentSample := mixer.Sample(Diluent, TotalVolumeperDilution)
		
		// Ensure liquid type set to Pre and Post Mix 
		firstDilution.Type = wtype.LTNeedToMix
		
		// sample from previous dilution sample
		nextSample := mixer.Sample(firstDilution, solutionVolume)
		
	    well, _ := findNextFreeWell(allwellpositions, WellsUsed)
		
		// Mix sample into nextdiluent sample
		nextDilution := MixNamed(OutPlate.Type, well, platename, nextDiluentSample, nextSample)
		
		// store all of the used wells in the WellsUsed slice.
				WellsUsed = append(WellsUsed, well)
				
		if newconcentration.RawValue() > 0  {
		// Calculate the conc entration for the next dilution based on the concentration of the previous dilution
		nextconcentration := wunit.DivideConcentration(newconcentration, float64(DilutionFactor))
		
		// Rename the next dilution sample to show its new concentration
		nextDilution.CName = nextconcentration.ToString() + " " + solutionname
		
		// Normalise the name to a format that can be parsed for DOE elements
		nextDilution.CName = normalise(nextDilution.CName)
		
		// Set the new concentration to the next concentration calculated ready for the next round of the loop
		newconcentration = nextconcentration
		}
		
		// add to dilutions array 
		dilutions = append(dilutions,nextDilution)
		
		// reset aliquot
		firstDilution = nextDilution
		
		}
		
		// Option to remove the excess solution volume in the last dilution to the input plate if equal volumes across all dilutions are desired.
		if RemoveExcessSolution {
		// Remove the aditional solution volume from the final dilution and move it to the input plate such that the final dilution volume equals the user defined final volume.
		disposeSample := mixer.Sample(firstDilution, solutionVolume)
		Mix(disposeSample)
		}
		
// export as Output
Dilutions = dilutions 

}
}

/*
// Check the wells that have already been used in this plate to be sure not to pipette on top of a previous solution. This is predominantly used for when two aliquot elements are used in serial to make sure the second set of aliquots are not pipette onto the first set.
func findNextFreeWell(allWellPositions []string,wellsUsed []string) (well string, err error){
		
			for _, well := range allWellPositions {
			// If a well position is found to already have been used then add one to our counter that specifies the next well to use. See step 2 of the following comments.
			if !search.InSlice(well,wellsUsed) {
				return well,nil
			}
		}
	return
}
*/
// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
	
}