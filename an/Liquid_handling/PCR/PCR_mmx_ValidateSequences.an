// Perform a single pcr reaction per element and validate that the primers will be expected to bind once each to the template sequence. Exact primer matches only.
// Thermocycle conditions are calculated from the input sequences and polymerase name
protocol PCR_mmx_ValidateSequences

import (
	"fmt"
	"strings"
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/enzymes"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/text"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/search"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/sequences"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/sequences/oligos"
)



// Input parameters for this protocol (data)
Parameters (
	// PCRprep parameters:
	ReactionName string
	TemplateSequence wtype.DNASequence
	FwdPrimerSeq wtype.DNASequence
	RevPrimerSeq wtype.DNASequence
	
	MasterMixVolume Volume
	PrimersalreadyAddedtoMasterMix bool
	PolymeraseAlreadyaddedtoMastermix bool
	FwdPrimerVol Volume
	RevPrimerVol Volume
	Templatevolume Volume
	PolymeraseVolume Volume

	OptionalWellPosition string // Leave blank for Antha to decide
	
	// Reaction parameters: (could be a entered as thermocycle parameters type possibly?)
	NumberOfCycles int 
	InitDenaturationTime Time
	DenaturationTime Time
	AnnealingTime Time
	FinalExtensionTime Time
	AnnealingTempOffset Temperature // degrees C below lowest MeltingTemp to set annealing Temperature.
)

// Data which is returned from this protocol, and data types
Data (
	Amplicon wtype.DNASequence
	FwdPrimerSites []search.Thingfound
	RevPrimerSites []search.Thingfound
	FwdPrimerMeltingTemp Temperature
	RevPrimerMeltingTemp Temperature
	AnnealingTemp Temperature
	ExtensionTime Time
	ExtensionTemp Temperature
	MeltingTemp Temperature
)


// Physical Inputs to this protocol with types
Inputs (
	FwdPrimer *wtype.LHComponent
	RevPrimer *wtype.LHComponent
	MasterMix *wtype.LHComponent
	PCRPolymerase *wtype.LHComponent
	Template *wtype.LHComponent
	OutPlate *wtype.LHPlate
)

// Physical outputs from this protocol with types
Outputs (
	Reaction *wtype.LHComponent
)

Requirements {
	

	
	
}

// Conditions to run on startup
Setup {
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
		
	// rename components

	Template.CName = TemplateSequence.Name()
	FwdPrimer.CName = FwdPrimerSeq.Name()
	RevPrimer.CName = RevPrimerSeq.Name()
	
	// check for non-specific binding. Exact matches only.
	FwdPrimerSites = sequences.FindSeqsinSeqs(TemplateSequence.Sequence(), []string{FwdPrimerSeq.Sequence()})
	
	RevPrimerSites = sequences.FindSeqsinSeqs(TemplateSequence.Sequence(), []string{RevPrimerSeq.Sequence()})

	
	if len(FwdPrimerSites)!=1 || len(RevPrimerSites)!=1{
	
	errordescription := fmt.Sprint(
						fmt.Sprint("Unexpected number of primer binding sites found in template"),
						text.Print("FwdPrimerSitesfound:", fmt.Sprint(FwdPrimerSites)),
						text.Print("RevPrimerSitesfound:", fmt.Sprint(RevPrimerSites)),
	)
	
	Errorf(errordescription)	
	}
	
	

	fwdposition := FwdPrimerSites[0].Positions[0]
	
	revposition := RevPrimerSites[0].Positions[0]
	
	var startposition int
	var endposition int
	
	if !FwdPrimerSites[0].Reverse && RevPrimerSites[0].Reverse && fwdposition < revposition {
		startposition = fwdposition
		endposition = revposition
	} else if FwdPrimerSites[0].Reverse && !RevPrimerSites[0].Reverse && fwdposition < revposition {
		startposition = revposition
		endposition = fwdposition
	}
	
	
	// work out what the pcr product will be
	Amplicon = oligos.DNAregion(TemplateSequence,startposition,endposition)
	
	
	
	// Make a mastermix

	mmxSample := mixer.Sample(MasterMix, MasterMixVolume)
	
	
	// pipette out to make mastermix
	mastermix := MixInto(OutPlate, OptionalWellPosition, mmxSample)
	
	// rest samples to zero
	samples := make([]*wtype.LHComponent, 0)
	
	// if this is false do stuff inside {}
	
	// add primers
	
	if !PrimersalreadyAddedtoMasterMix {
	FwdPrimerSample := mixer.Sample(FwdPrimer, FwdPrimerVol)
	samples = append(samples, FwdPrimerSample)
	RevPrimerSample := mixer.Sample(RevPrimer, RevPrimerVol)
	samples = append(samples, RevPrimerSample)
	}
	
	
	// add template
	templateSample := mixer.Sample(Template, Templatevolume)
	samples = append(samples, templateSample)

	
	for j := range samples { 
	mastermix = Mix(mastermix, samples[j])
	}
	reaction := mastermix

	// this needs to go after an initial denaturation!
	if !PolymeraseAlreadyaddedtoMastermix {
	polySample := mixer.Sample(PCRPolymerase, PolymeraseVolume)
	
	reaction = Mix(reaction,polySample)
	}

	// thermocycle parameters called from enzyme lookup:

	polymerase := PCRPolymerase.CName


	polymeraseproperties, polymerasefound := enzymes.DNApolymerasetemps[polymerase]
	
	if !polymerasefound {
		validoptions := make([]string,0)
		for polymerasename, _ := range enzymes.DNApolymerasetemps{
			validoptions = append(validoptions,polymerasename)
			}
		
		Errorf("No Properties for", polymerase, "found.", "Valid options are:",strings.Join(validoptions,","))
	}

	var found bool

	ExtensionTemp, found = polymeraseproperties["extensiontemp"]
	if !found{
		Errorf("No extension temp found for polymerase ",polymerase )
	}
	MeltingTemp, found = polymeraseproperties["meltingtemp"]
	if !found{
		Errorf("No melting temp found for polymerase ",polymerase )
	}

	var err error

	ExtensionTime, err = enzymes.CalculateExtensionTime(PCRPolymerase, Amplicon) 
	
	if err != nil {
		Errorf("Can't calculate extension time of polymerase.",  err.Error())
	}


	// work out annealing temperature
	
	FwdPrimerMeltingTemp = oligos.BasicMeltingTemp(FwdPrimerSeq)
	
	RevPrimerMeltingTemp = oligos.BasicMeltingTemp(RevPrimerSeq)

	// check which primer has the lowest melting temperature
	if FwdPrimerMeltingTemp.SIValue() < RevPrimerMeltingTemp.SIValue(){
		// start PCR AnnealingTempOffset degrees below lowest melting temp
		AnnealingTemp = wunit.NewTemperature(FwdPrimerMeltingTemp.SIValue()- AnnealingTempOffset.SIValue(),"C")
	}else{
		// start PCR AnnealingTempOffset degrees below lowest melting temp
		AnnealingTemp = wunit.NewTemperature(RevPrimerMeltingTemp.SIValue()- AnnealingTempOffset.SIValue(),"C")
	}

	// initial Denaturation

	r1 := Incubate(reaction, MeltingTemp, InitDenaturationTime, false)
	
	for i:=0; i < NumberOfCycles; i++ {
		
		// Denature

	r1 = Incubate(r1, MeltingTemp, DenaturationTime, false)
	
		// Anneal
	r1 = Incubate(r1, AnnealingTemp, AnnealingTime, false)
		
		// Extend
	r1 = Incubate(r1, ExtensionTemp, ExtensionTime, false)
		
	}
		// Final Extension
	r1 = Incubate(r1, ExtensionTemp, FinalExtensionTime, false)
	

	// all done
	Reaction = r1
	
	Reaction.CName = ReactionName
}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
}

/*type Polymerase struct {
	wtype.LHComponent
	Rate_BPpers float64
	Fidelity_errorrate float64 // could dictate how many colonies are checked in validation!
	Extensiontemp Temperature
	Hotstart bool
	StockConcentration Concentration // this is normally in U?
	TargetConcentration Concentration
	// this is also a glycerol solution rather than a watersolution!
}
*/
