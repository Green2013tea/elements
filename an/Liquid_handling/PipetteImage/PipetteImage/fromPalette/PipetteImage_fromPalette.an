// Generates instructions to pipette out a defined image onto a defined plate using a defined palette of colours
protocol PipetteImage_fromPalette

import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/image"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/download"
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"image/color"
	"strconv"
	"strings"
	"fmt"
	goimage "image"
)


// Input parameters for this protocol (data)
Parameters (
	VolumePerWell  Volume
	Imagefilename string // name of image file or if using URL use this field to set the desired filename
	UseURL bool // select this if getting the image from a URL
	URL string // enter URL link to the image file here if applicable
	Palette color.Palette
	ColourIndextoComponentMap map[string]string
	OnlythisColour string
	NotthisColour string
	Rotate bool
	AutoRotate bool
	PosterizeImage bool
	PosterizeLevels int
	LiquidType wtype.PolicyName
	LowerThreshold uint8
)

// Data which is returned from this protocol, and data types
Data (
	Numberofpixels int
)


// Physical Inputs to this protocol with types
Inputs (
	Colourcomponents []*LHComponent
	OutPlate *LHPlate
)

// Physical outputs from this protocol with types
Outputs (
	Pixels[]*LHComponent
)

Requirements {
	
}

// Conditions to run on startup
Setup {
	
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {


	//-------------------------------------------------------------------------------------
	//Globals
	//-------------------------------------------------------------------------------------

	var imgFile File
	var imgBase *goimage.NRGBA

	var err error

	//-------------------------------------------------------------------------------------
	//Fetching image
	//-------------------------------------------------------------------------------------

	// if image is from url, download
	if UseURL {
		//downloading image
		imgFile , err = download.File(URL, Imagefilename)
		if err != nil{
			Errorf(err.Error())
		}

		//opening the image file
		imgBase, err = image.OpenFile(imgFile)
		if err != nil{
			Errorf(err.Error())
		}
	}

	//-------------------------------------------------------------------------------------
	//Image processing
	//-------------------------------------------------------------------------------------
	
	if PosterizeImage{

		imgBase, err = image.Posterize(imgBase, PosterizeLevels)
		if err != nil{
			Errorf(err.Error())
		}
	}
	
	positiontocolourmap, _ := image.ImagetoPlatelayout(imgBase, OutPlate, &Palette, Rotate,AutoRotate)
	
	
	image.CheckAllResizealgorithms(imgBase,OutPlate,Rotate,image.AllResampleFilters)

	//-------------------------------------------------------------------------------------
	//Pipetting
	//-------------------------------------------------------------------------------------

	solutions := make([]*LHComponent, 0)
	counter := 0

	for locationkey, colour := range positiontocolourmap {
		
		
			if  col, found := image.Colourcomponentmap[colour]; found {
				if col == NotthisColour {
					Errorf("Not this component:", col)
				}
			}
		
		cmyk := image.ColourtoCMYK(colour)
				
		// temp skip of wells with x, e.g. x1,x2,x12
		
		if cmyk.C  <= LowerThreshold && cmyk.Y <= LowerThreshold && cmyk.M <= LowerThreshold && cmyk.K <= LowerThreshold {
			// skip pixel
		}else if strings.Contains(locationkey,"x") || strings.Contains(locationkey,"X")  {
			// skip pixel
		}else {
			// pipette this pixel
			colourindex := strconv.Itoa(Palette.Index(colour))
			
			compName, componentpresent := ColourIndextoComponentMap[colourindex]
			
			component, err := findComponent(Colourcomponents, compName)
			
			if err != nil {
				Errorf("Cannot find component: ", err.Error())
			}
			
				if componentpresent && component.CName == NotthisColour {
					Errorf("Not this component:", image.Colourcomponentmap[colour])
				}
			
			/*	
			if !componentpresent {
				
			
			for key, _ := range ColourIndextoComponentMap {
				foundthese = append(foundthese,key)
			}
			sort.Strings(foundthese)
			Errorf("Component ", colourindex, "not found in ColourIndextoComponentMap.", "Found these entries only: ", strings.Join(foundthese, ","))
			}
			*/
		
			if componentpresent {
				
					if LiquidType != ""{
					component.Type, err = wtype.LiquidTypeFromString(LiquidType)
					
					if err != nil {
						Errorf("for component",component.CName, err.Error())
					}
				}
				if OnlythisColour !="" {
			
					if image.Colourcomponentmap[colour] == OnlythisColour{
							counter = counter + 1
			
						pixelSample := mixer.Sample(component, VolumePerWell)
						solution := MixTo(OutPlate.Type, locationkey, 1, pixelSample)
						solutions = append(solutions, solution)
						}
					
				}else{
					
					if NotthisColour == ""{
						counter++
						pixelSample := mixer.Sample(component, VolumePerWell)
						solution := MixNamed(OutPlate.Type, locationkey, "Image", pixelSample)
						solutions = append(solutions, solution)
					}else if component.CName != NotthisColour && image.Colourcomponentmap[colour] != NotthisColour {
						counter++
						pixelSample := mixer.Sample(component, VolumePerWell)
						solution := MixNamed(OutPlate.Type, locationkey, "Image", pixelSample)
						solutions = append(solutions, solution)
					}else{
						Errorf("component: NotthisColourFound: ", component.CName)
					}
				}
				
			}	
		}
	}
	Pixels = solutions
	Numberofpixels = len(Pixels)
	
}
// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
	
}

// Looks for a component matching on name only.
// If more than one component present the first component will be returned with no error
func findComponent(components []*LHComponent, componentName string)(component *LHComponent, err error){
	for _,comp := range components {
		if comp.CName == componentName {
			return comp, nil
		}
	}
	return component, fmt.Errorf("No component found with name %s in component list",componentName)
}

