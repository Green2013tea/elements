// Protocol for parsing the contents of a DNAPlate file in xlsx format from Thermo.
// The products of parsing this plate can the be wired directly into the ResuspendDNA or PairOligos elements.
protocol ParseDNAPlateFile

// we need to import the wtype package to use the LHComponent type
// the mixer package is required to use the Sample function
import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"strings"
	"fmt"
	"github.com/antha-lang/antha/microArch/factory"
	"github.com/antha-lang/antha/antha/AnthaStandardLibrary/Packages/doe"
)


// Input parameters for this protocol (data)
Parameters (
  	SequenceInfoFile File // supported format is xlsx file from Thermo
	SequenceInfoFileformat string // default should be JMP
)

Data (
	Partnames []string
	PartSeqs map[string]DNASequence
	PartMassMap map[string]Mass
	PartMolecularWeightMap map[string]float64
	PartPlateMap map[string]string
	PartLocationsMap map[string]string
	FwdOligotoRevOligo map[string]string // using the fwd primer name, returns the rev primer name
	OligoPairs int
	HeadersFound []string
)

Inputs (
)

Outputs (
	PartsList map[string]*LHComponent
)

Requirements {
}

Setup {	
}


Steps {


	if SequenceInfoFileformat == ""{
		SequenceInfoFileformat = "JMP"
	}
	
	var ReplaceMap = map[string]string{
		"01":"1",
		"02":"2",
		"03":"3",
		"04":"4",
		"05":"5",
		"06":"6",
		"07":"7",
		"08":"8",
		"09":"9",
		"_":"",
	}
	
	
	// headers
	NameHeader := "Seq Name"
	seqHeader := "Seq"
	MassHeader := "Yield_ug"
	MWHeader := "MW"
	WellHeader := "Customer Well"
	PlateNameHeader := "Plate"
	volHeader := "Volume_ul"
	concHeader := "Conc_ug/ul"


	// initialise maps
	PartMassMap = make(map[string]Mass)
	PartMolecularWeightMap = make(map[string]float64)
	PartLocationsMap = make(map[string]string)
	PartPlateMap = make(map[string]string)
	headersfound := make([]string,0)
	FwdOligotoRevOligo = make(map[string]string)
	PartsList = make(map[string]*LHComponent)

	// get contents from file
	fileContents, err :=  SequenceInfoFile.ReadAll()
	
	if err!= nil {
		Errorf(err.Error())
	}
	

	dnaparts, err := doe.RunsFromDesignPreResponsesContents(fileContents,[]string{"Length", "MW","Tm","Yield"},SequenceInfoFileformat)

	if err!= nil {
		Errorf(err.Error())
	}
	
	// code for parsing the data from the xl file into the strings, this searches the file in direction i followed by j
	for i, partinfo := range dnaparts {
		
		
		var partname string
		var partmass float64
		var partwell string
		var partmw float64
		var platename string
		var partSeq string
		var partConc float64
		var partVol float64
		
		for j := range partinfo.Setpoints {
			
			//First creates an array of part names	
			if partinfo.Factordescriptors[j] == NameHeader {
				
				if	name, found := partinfo.Setpoints[j].(string); found{
					
					if name == ""|| name == "BLANK"{
						fmt.Print("Skipping ", name)
					}else{
						partname = name
						Partnames = append(Partnames,name)
					}
					
				} else {
					Errorf(fmt.Sprint("wrong type", partinfo.Factordescriptors[j],partinfo.Setpoints[j]))
				}
				
				if i == 0 {
					headersfound = append(headersfound,NameHeader)
				}
				
			}
			
			//second create an array of plasmid masses	
			if partinfo.Factordescriptors[j] == MassHeader {
				
				if	mass, found := partinfo.Setpoints[j].(float64); found{
					partmass = mass
				}  else if	mass, found := partinfo.Setpoints[j].(string); found{
					if mass == ""{
						partmass = 0.0 // mw
					// empty so skip
					}
				}else {
					Errorf(fmt.Sprint("wrong type", partinfo.Factordescriptors[j],partinfo.Setpoints[j]))
				}
				
				if i == 0 {
					headersfound = append(headersfound,MassHeader)
				}
			}
		
			if partinfo.Factordescriptors[j] == MWHeader {
				
				if	mw, found := partinfo.Setpoints[j].(int); found{
					partmw = float64(mw)
				}  else if	mw, found := partinfo.Setpoints[j].(float64); found{
					partmw = mw
				}  else if	mw, found := partinfo.Setpoints[j].(string); found{
					if mw == ""{
					partmw = 0.0 // mw
					// empty so skip
					}
				}else {
					Errorf(fmt.Sprint("wrong type", partinfo.Factordescriptors[j],partinfo.Setpoints[j]))
				}
				
				if  i == 0 {
				headersfound = append(headersfound,MWHeader)
				}
			}
			
			if partinfo.Factordescriptors[j] == seqHeader {
				
				if seq, found := partinfo.Setpoints[j].(string); found{
					partSeq = seq
				} else {
					Errorf(fmt.Sprint("wrong type", partinfo.Factordescriptors[j],partinfo.Setpoints[j]))
				}
				
				if  i == 0 {
					headersfound = append(headersfound,seqHeader)
				}
			}
			
			if partinfo.Factordescriptors[j] == volHeader {
				
				if	vol, found := partinfo.Setpoints[j].(float64); found{
					partVol = vol
				}  else if vol, found := partinfo.Setpoints[j].(string); found{
					if vol == ""{
						partVol = 0.0 // mw
					// empty so skip
					}
				}else {
					Errorf(fmt.Sprint("wrong type", partinfo.Factordescriptors[j],partinfo.Setpoints[j]))
				}
				
				if i == 0 {
					headersfound = append(headersfound,volHeader)
				}
			}
			
			if partinfo.Factordescriptors[j] == concHeader {
				
				if	conc, found := partinfo.Setpoints[j].(float64); found{
					partConc = conc
				}  else if conc, found := partinfo.Setpoints[j].(string); found{
					if conc == ""{
						partConc = 0.0 // mw
					// empty so skip
					}
				}else {
					Errorf(fmt.Sprint("wrong type", partinfo.Factordescriptors[j],partinfo.Setpoints[j]))
				}
				
				if i == 0 {
					headersfound = append(headersfound,concHeader)
				}
			}
			
			if partinfo.Factordescriptors[j] == WellHeader {
				
				if	well, found := partinfo.Setpoints[j].(string); found{
					
					for key, value := range ReplaceMap {
					
					if strings.Contains(well,key){
						well = strings.Replace(well,key,value,1)
				
						break
					}
					}
					partwell = well
				}  else {
					Errorf(fmt.Sprint("wrong type", partinfo.Factordescriptors[j],partinfo.Setpoints[j]))
				}
				
				if  i == 0 {
					headersfound = append(headersfound,WellHeader)
				}
			}
		
			//third creates an array of part lengths in bp	
			if partinfo.Factordescriptors[j] == PlateNameHeader {
				
				if	plate, found := partinfo.Setpoints[j].(string); found{
					
					platename = plate
				}  else {
					Errorf(fmt.Sprint("wrong type", partinfo.Factordescriptors[j],partinfo.Setpoints[j]))
				}
				if  i == 0 {
					headersfound = append(headersfound,PlateNameHeader)
				}
			}
			
			
		//internal check if there are not 4 headers (as we know there should be 4) return an error telling us which ones were found and which were not	
			/*
			if len(headersfound)!= 4 {
				Errorf(fmt.Sprint("Only found these headers in input file: ", headersfound))
			}
			*/
		}
		
		if partname == "" || partname == "BLANK"{
			fmt.Print("Skipping ", partname)
		}else{
			PartLocationsMap[partname] = partwell
			PartMolecularWeightMap[partname] = partmw
			PartMassMap[partname] = wunit.NewMass(partmass,"ug")
			PartPlateMap[partname]= platename
			
			part := factory.GetComponentByType("dna_part")
			part.CName = partname
			
			if partVol > 0.0 {
				part.SetVolume(wunit.NewVolume(partVol,"ul"))
			}
			
			if partConc > 0.0 {
				part.SetConcentration(wunit.NewConcentration(partConc,"ug/ul"))
			}
			
			PartsList[partname] = part
			
			var seq DNASequence
			seq.Nm = partname
			seq.Seq = partSeq
			
			PartSeqs[partname] = seq
		}
	
	}
	
	for _, partname := range Partnames {
		
		if !strings.Contains(partname, "_Revers"){
			for _, partname2 := range Partnames {
				if strings.Contains(partname2, "_Revers")&& strings.Contains(partname2, partname){
					FwdOligotoRevOligo[partname] = partname2
					break
					}
				}
		}
	
	}
	OligoPairs = len(FwdOligotoRevOligo)
	
	HeadersFound = headersfound
}

Analysis {
}


Validation {
}
