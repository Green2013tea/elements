// Adds a list of components to a mastermix.
// Volumes of each component are specified by a map. 
// A default volume may be specified which applies to all which are not present explicitely in the map.
// 20% extra volume is made up to ensure sufficient volume is made i.e. accounting for dead volumes etc.
protocol AddToMastermix

import (
	"github.com/antha-lang/antha/antha/anthalib/wtype"
	"github.com/antha-lang/antha/antha/anthalib/wutil"
	"github.com/antha-lang/antha/antha/anthalib/mixer"
	"github.com/antha-lang/antha/microArch/factory"
	"github.com/antha-lang/antha/antha/anthalib/setup"
	"strconv"
)


// Input parameters for this protocol (data)
Parameters (
	// Specify volume per component name per reaction or specify a "default" to apply to all.
	// The actual volume added will be multiplied by the number of Reactionspermastermix
	VolumesToAdd 			map[string]Volume 
	
	// List of names of components to be added
	// These will be used to look up components by name in the factory. 
	// If not found in the factory, new components will be created using dna_mix as a template
	// If empty, the the ComponentIn will be returned as an output
	ComponentsToAdd 		[]string
	
	// This specifies the multiplier of each of the Volumes for each component to add
	// e.g. if "glucose": "1ul" and Reactionspermastermix == 3 then 3ul glucose is added to mastermix
	Reactionspermastermix 	int
	
	// If using the inventory system, select whether to check inventory for parts so missing parts may be ordered.
	CheckPartsInInventory 	bool
	
	// If this is selected the mastermix will be moved to a new location specified by OutPlate type
	// If not selected, the components will be added to the ComponentIn
	MixToNewLocation		bool
	
	// Factor of total volume to make up as extra volume to account for evaporation.
	// Default is 0.2 (20%)
	MakeExtraPercentage float64
)

// Data which is returned from this protocol, and data types
Data (
	Status string
	VolumesUsed map[string]Volume
)


// Physical Inputs to this protocol with types
Inputs (
	// The component to add all new components to.
	ComponentIn *LHComponent
	
	// if MixToNewLocation is set to true this will be the plate type which the mastermix will be transferred to.
	// Otherwise the residual volume will be used to added to the total volume to add, 
	// so this plate should be selected as teh plate in which the mastermix is already in.
	OutPlate *LHPlate
)

// Physical outputs from this protocol with types
Outputs (
	Mastermix *LHComponent
)

Requirements {
}

// Conditions to run on startup
Setup {
}

// The core process for this protocol, with the steps to be performed
// for every input
Steps {
	
	VolumesUsed = make(map[string]Volume)
	
	var factor float64
	
	if MakeExtraPercentage == 0.0 {
		factor = 0.1
	}
	
	if MakeExtraPercentage >= 0.0 && MakeExtraPercentage < 1 {
		factor = 1.0 + MakeExtraPercentage 
	}else{
		Errorf("MakeExtraPercentage needs to be specified between 0.01 (1%) and 1 (100%) but specified as %f. Leave as zero to use default of 0.1 (10%)",MakeExtraPercentage)
	}
	
	// make up extra volume based on MakeExtraPercentage parameter to ensure reagents are sufficient accounting for dead volumes and evaporation
	extraReactions := float64(Reactionspermastermix) * factor
		
	roundedReactions, err := wutil.RoundDown(extraReactions)
	
	if err != nil {
		Errorf(err.Error())
	}
	
	roundedUpReactions := roundedReactions + 1
	
	if roundedUpReactions <= Reactionspermastermix  {
		Reactionspermastermix = Reactionspermastermix + 1
	}else {
		Reactionspermastermix = roundedUpReactions
	}
	
		// if no components to add, return original component in as output
		if len(ComponentsToAdd)==0{
			
			if MixToNewLocation {
				Mastermix = MixInto(OutPlate, "",  ComponentIn)
			}else{
				Mastermix = ComponentIn
			}
 			Status = "No Components added to Mastermix"
			
			}else{
	
		var mastermix *LHComponent
	
		// get components from factory and if not present use default dna component
		
		lhComponents := make([]*LHComponent,0)
		
		if MixToNewLocation {
			lhComponents = append(lhComponents,ComponentIn)
		}
		for _,component := range ComponentsToAdd {
			
			if factory.ComponentInFactory(component){
				lhComponents = append(lhComponents,factory.GetComponentByType(component))
			}else {
				// if component not in factory use dna as default component type
				defaultcomponent := factory.GetComponentByType("dna")
				defaultcomponent.CName = component
				lhComponents = append(lhComponents,defaultcomponent)
			}
			
		}
		
		if CheckPartsInInventory {
	
		// First specify some handles for UI interaction
		// Adds Ordering handle for the UI
		lhComponents[0] = Handle(setup.OrderInfo(lhComponents[0]))
		// we need a plate prep step
		lhComponents[0] = Handle(setup.PlatePrep(lhComponents[0]))

		// a setup step
   	 	lhComponents[0] = Handle(setup.MarkForSetup(lhComponents[0]))
		}
		
		
		var adjustedVols []Volume
		// adjust volumes
		for _, component := range lhComponents { 	
			
			var volToUse Volume
			
			if vol, found := VolumesToAdd[component.CName];found{
				volToUse = vol
			}else if vol, found := VolumesToAdd["default"];found{
				volToUse = vol
			}else{
				Errorf("No volume for %s or default volume specified.",component.CName)
			}
				
			// multiply volume of each component by number of reactions per mastermix
			adjustedVol := wunit.MultiplyVolume(volToUse,float64(Reactionspermastermix))
			
			adjustedVols = append(adjustedVols,adjustedVol)
			
		}
		
		// Add volumes to work out total volume
		prelimTotalVol := wunit.AddVolumes(adjustedVols)
		
		// include volume of original component
		prelimTotalVol = wunit.AddVolumes([]Volume{ComponentIn.Volume(),prelimTotalVol})
		
		// now make mastermix
		
		eachmastermix := make([]*LHComponent, 0)
		
		for k, component := range lhComponents { 	
			
			if k == len(lhComponents)-1{
				component.Type = wtype.LTMegaMix 
			}
		
			adjustedvol := adjustedVols[k]
			
			// now account for residual volume
			var nilPlate *LHPlate
			
			if OutPlate != nilPlate {
				residualVol := OutPlate.Welltype.ResidualVolume()
				
				proportionOfresidualVol := wunit.MultiplyVolume(residualVol,float64(adjustedvol.SIValue()/prelimTotalVol.SIValue()))
				
				adjustedvol = wunit.AddVolumes([]Volume{adjustedvol,proportionOfresidualVol})
				
				if OutPlate.Welltype.MaxVolume().LessThan(adjustedvol){
					Errorf("After accounting for residual well volume of %s, the Volume required of %s is too high for the %s well capacity of %s. Please select a plate with a large enough well capacity for this volume",residualVol,adjustedvol,OutPlate.Name(),OutPlate.Welltype.MaxVolume().ToString())
				}	
				if _, found := VolumesUsed[component.CName];!found{
					VolumesUsed[component.CName] = adjustedvol
				}else{
					var counter int
					for counter < 100 {
						name := component.CName + strconv.Itoa(counter)
						if _, found := VolumesUsed[name];!found{
							VolumesUsed[component.CName] = adjustedvol
							break
						}
						counter++
					}
				}
			}
			
				
			componentSample := mixer.Sample(component,adjustedvol)
			
			eachmastermix = append(eachmastermix,componentSample)
			
		
		}
	if MixToNewLocation {
		mastermix = MixInto(OutPlate, "",  eachmastermix...)
	}else{
		for i := range eachmastermix{
			
			if i == 0{
				mastermix = ComponentIn
			}
			
			mastermix =	Mix(mastermix,eachmastermix[i])
		}
	}
	Mastermix = mastermix

	
 	Status = "Mastermix Made"
	}
}

// Run after controls and a steps block are completed to
// post process any data and provide downstream results
Analysis {
}

// A block of tests to perform to validate that the sample was processed correctly
// Optionally, destructive tests can be performed to validate results on a
// dipstick basis
Validation {
}
